// Code generated from FSH.g4 by ANTLR 4.13.2. DO NOT EDIT.

package grammar // FSH
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type FSHParser struct {
	*antlr.BaseParser
}

var FSHParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func fshParserInit() {
	staticData := &FSHParserStaticData
	staticData.LiteralNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "'?!'", "'MS'", "'SU'", "'TU'", "'N'",
		"'D'", "'from'", "", "", "", "", "'contains'", "'named'", "'and'", "'only'",
		"'or'", "'obeys'", "'true'", "'false'", "'include'", "'exclude'", "'codes'",
		"'where'", "'valueset'", "'system'", "", "'insert'", "'contentReference'",
		"'='", "", "':'", "','", "'->'",
	}
	staticData.SymbolicNames = []string{
		"", "KW_ALIAS", "KW_PROFILE", "KW_EXTENSION", "KW_INSTANCE", "KW_INSTANCEOF",
		"KW_INVARIANT", "KW_VALUESET", "KW_CODESYSTEM", "KW_RULESET", "KW_MAPPING",
		"KW_LOGICAL", "KW_RESOURCE", "KW_PARENT", "KW_ID", "KW_TITLE", "KW_DESCRIPTION",
		"KW_EXPRESSION", "KW_XPATH", "KW_SEVERITY", "KW_USAGE", "KW_SOURCE",
		"KW_TARGET", "KW_CONTEXT", "KW_CHARACTERISTICS", "KW_MOD", "KW_MS",
		"KW_SU", "KW_TU", "KW_NORMATIVE", "KW_DRAFT", "KW_FROM", "KW_EXAMPLE",
		"KW_PREFERRED", "KW_EXTENSIBLE", "KW_REQUIRED", "KW_CONTAINS", "KW_NAMED",
		"KW_AND", "KW_ONLY", "KW_OR", "KW_OBEYS", "KW_TRUE", "KW_FALSE", "KW_INCLUDE",
		"KW_EXCLUDE", "KW_CODES", "KW_WHERE", "KW_VSREFERENCE", "KW_SYSTEM",
		"KW_EXACTLY", "KW_INSERT", "KW_CONTENTREFERENCE", "EQUAL", "STAR", "COLON",
		"COMMA", "ARROW", "STRING", "MULTILINE_STRING", "NUMBER", "UNIT", "CODE",
		"CONCEPT_STRING", "DATETIME", "TIME", "CARD", "REFERENCE", "CODEABLE_REFERENCE",
		"CANONICAL", "CARET_SEQUENCE", "REGEX", "BLOCK_COMMENT", "SEQUENCE",
		"WHITESPACE", "LINE_COMMENT", "PARAM_RULESET_REFERENCE", "RULESET_REFERENCE",
		"BRACKETED_PARAM", "LAST_BRACKETED_PARAM", "PLAIN_PARAM", "LAST_PLAIN_PARAM",
		"QUOTED_CONTEXT", "LAST_QUOTED_CONTEXT", "UNQUOTED_CONTEXT", "LAST_UNQUOTED_CONTEXT",
		"CONTEXT_WHITESPACE", "CODE_ITEM", "LAST_CODE_ITEM", "CODE_LIST_WHITESPACE",
	}
	staticData.RuleNames = []string{
		"doc", "entity", "alias", "profile", "extension", "logical", "resource",
		"sdMetadata", "sdRule", "lrRule", "instance", "instanceMetadata", "instanceRule",
		"invariant", "invariantMetadata", "invariantRule", "valueSet", "vsMetadata",
		"vsRule", "codeSystem", "csMetadata", "csRule", "ruleSet", "ruleSetRule",
		"paramRuleSet", "paramRuleSetRef", "parameter", "lastParameter", "paramRuleSetContent",
		"mapping", "mappingMetadata", "mappingEntityRule", "parent", "id", "title",
		"description", "expression", "xpath", "severity", "instanceOf", "usage",
		"source", "target", "context", "contextItem", "lastContextItem", "characteristics",
		"cardRule", "flagRule", "valueSetRule", "fixedValueRule", "containsRule",
		"onlyRule", "obeysRule", "caretValueRule", "codeCaretValueRule", "mappingRule",
		"insertRule", "codeInsertRule", "addCRElementRule", "addElementRule",
		"pathRule", "vsComponent", "vsConceptComponent", "vsFilterComponent",
		"vsComponentFrom", "vsFromSystem", "vsFromValueset", "vsFilterList",
		"vsFilterDefinition", "vsFilterOperator", "vsFilterValue", "name", "path",
		"caretPath", "flag", "strength", "value", "item", "code", "concept",
		"quantity", "ratio", "reference", "referenceType", "codeableReferenceType",
		"canonical", "ratioPart", "bool", "targetType", "mostAlphaKeywords",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 89, 837, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57,
		2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2,
		63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 68,
		7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 7,
		73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 78,
		2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83, 2,
		84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2, 89,
		7, 89, 2, 90, 7, 90, 1, 0, 5, 0, 184, 8, 0, 10, 0, 12, 0, 187, 9, 0, 1,
		0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 3, 1, 203, 8, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 3, 1, 3, 1,
		3, 4, 3, 213, 8, 3, 11, 3, 12, 3, 214, 1, 3, 5, 3, 218, 8, 3, 10, 3, 12,
		3, 221, 9, 3, 1, 4, 1, 4, 1, 4, 1, 4, 5, 4, 227, 8, 4, 10, 4, 12, 4, 230,
		9, 4, 1, 4, 5, 4, 233, 8, 4, 10, 4, 12, 4, 236, 9, 4, 1, 5, 1, 5, 1, 5,
		1, 5, 5, 5, 242, 8, 5, 10, 5, 12, 5, 245, 9, 5, 1, 5, 5, 5, 248, 8, 5,
		10, 5, 12, 5, 251, 9, 5, 1, 6, 1, 6, 1, 6, 5, 6, 256, 8, 6, 10, 6, 12,
		6, 259, 9, 6, 1, 6, 5, 6, 262, 8, 6, 10, 6, 12, 6, 265, 9, 6, 1, 7, 1,
		7, 1, 7, 1, 7, 3, 7, 271, 8, 7, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1,
		8, 1, 8, 1, 8, 1, 8, 3, 8, 283, 8, 8, 1, 9, 1, 9, 1, 9, 3, 9, 288, 8, 9,
		1, 10, 1, 10, 1, 10, 5, 10, 293, 8, 10, 10, 10, 12, 10, 296, 9, 10, 1,
		10, 5, 10, 299, 8, 10, 10, 10, 12, 10, 302, 9, 10, 1, 11, 1, 11, 1, 11,
		1, 11, 3, 11, 308, 8, 11, 1, 12, 1, 12, 1, 12, 3, 12, 313, 8, 12, 1, 13,
		1, 13, 1, 13, 5, 13, 318, 8, 13, 10, 13, 12, 13, 321, 9, 13, 1, 13, 5,
		13, 324, 8, 13, 10, 13, 12, 13, 327, 9, 13, 1, 14, 1, 14, 1, 14, 1, 14,
		3, 14, 333, 8, 14, 1, 15, 1, 15, 1, 15, 3, 15, 338, 8, 15, 1, 16, 1, 16,
		1, 16, 5, 16, 343, 8, 16, 10, 16, 12, 16, 346, 9, 16, 1, 16, 5, 16, 349,
		8, 16, 10, 16, 12, 16, 352, 9, 16, 1, 17, 1, 17, 1, 17, 3, 17, 357, 8,
		17, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 364, 8, 18, 1, 19, 1, 19,
		1, 19, 5, 19, 369, 8, 19, 10, 19, 12, 19, 372, 9, 19, 1, 19, 5, 19, 375,
		8, 19, 10, 19, 12, 19, 378, 9, 19, 1, 20, 1, 20, 1, 20, 3, 20, 383, 8,
		20, 1, 21, 1, 21, 1, 21, 3, 21, 388, 8, 21, 1, 22, 1, 22, 1, 22, 4, 22,
		393, 8, 22, 11, 22, 12, 22, 394, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1,
		23, 1, 23, 1, 23, 3, 23, 405, 8, 23, 1, 24, 1, 24, 1, 24, 1, 24, 1, 25,
		1, 25, 5, 25, 413, 8, 25, 10, 25, 12, 25, 416, 9, 25, 1, 25, 1, 25, 1,
		26, 1, 26, 1, 27, 1, 27, 1, 28, 1, 28, 5, 28, 426, 8, 28, 10, 28, 12, 28,
		429, 9, 28, 1, 29, 1, 29, 1, 29, 5, 29, 434, 8, 29, 10, 29, 12, 29, 437,
		9, 29, 1, 29, 5, 29, 440, 8, 29, 10, 29, 12, 29, 443, 9, 29, 1, 30, 1,
		30, 1, 30, 1, 30, 1, 30, 3, 30, 450, 8, 30, 1, 31, 1, 31, 1, 31, 3, 31,
		455, 8, 31, 1, 32, 1, 32, 1, 32, 1, 33, 1, 33, 1, 33, 1, 34, 1, 34, 1,
		34, 1, 35, 1, 35, 1, 35, 1, 36, 1, 36, 1, 36, 1, 37, 1, 37, 1, 37, 1, 38,
		1, 38, 1, 38, 1, 39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 40, 1, 41, 1, 41, 1,
		41, 1, 42, 1, 42, 1, 42, 1, 43, 1, 43, 5, 43, 492, 8, 43, 10, 43, 12, 43,
		495, 9, 43, 1, 43, 1, 43, 1, 44, 1, 44, 1, 45, 1, 45, 1, 46, 1, 46, 5,
		46, 505, 8, 46, 10, 46, 12, 46, 508, 9, 46, 1, 46, 1, 46, 1, 47, 1, 47,
		1, 47, 1, 47, 5, 47, 516, 8, 47, 10, 47, 12, 47, 519, 9, 47, 1, 48, 1,
		48, 1, 48, 1, 48, 5, 48, 525, 8, 48, 10, 48, 12, 48, 528, 9, 48, 1, 48,
		4, 48, 531, 8, 48, 11, 48, 12, 48, 532, 1, 49, 1, 49, 1, 49, 1, 49, 1,
		49, 3, 49, 540, 8, 49, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 547, 8,
		50, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 5, 51, 555, 8, 51, 10, 51,
		12, 51, 558, 9, 51, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 5, 52, 566,
		8, 52, 10, 52, 12, 52, 569, 9, 52, 1, 53, 1, 53, 3, 53, 573, 8, 53, 1,
		53, 1, 53, 1, 53, 1, 53, 5, 53, 579, 8, 53, 10, 53, 12, 53, 582, 9, 53,
		1, 54, 1, 54, 3, 54, 586, 8, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 55, 1,
		55, 5, 55, 594, 8, 55, 10, 55, 12, 55, 597, 9, 55, 1, 55, 1, 55, 1, 55,
		1, 55, 1, 56, 1, 56, 3, 56, 605, 8, 56, 1, 56, 1, 56, 1, 56, 3, 56, 610,
		8, 56, 1, 56, 3, 56, 613, 8, 56, 1, 57, 1, 57, 3, 57, 617, 8, 57, 1, 57,
		1, 57, 1, 57, 3, 57, 622, 8, 57, 1, 58, 1, 58, 5, 58, 626, 8, 58, 10, 58,
		12, 58, 629, 9, 58, 1, 58, 1, 58, 1, 58, 3, 58, 634, 8, 58, 1, 59, 1, 59,
		1, 59, 1, 59, 5, 59, 640, 8, 59, 10, 59, 12, 59, 643, 9, 59, 1, 59, 1,
		59, 1, 59, 1, 59, 3, 59, 649, 8, 59, 1, 60, 1, 60, 1, 60, 1, 60, 5, 60,
		655, 8, 60, 10, 60, 12, 60, 658, 9, 60, 1, 60, 1, 60, 1, 60, 5, 60, 663,
		8, 60, 10, 60, 12, 60, 666, 9, 60, 1, 60, 1, 60, 3, 60, 670, 8, 60, 1,
		61, 1, 61, 1, 61, 1, 62, 1, 62, 3, 62, 677, 8, 62, 1, 62, 1, 62, 3, 62,
		681, 8, 62, 1, 63, 1, 63, 3, 63, 685, 8, 63, 1, 64, 1, 64, 1, 64, 1, 64,
		3, 64, 691, 8, 64, 1, 65, 1, 65, 1, 65, 1, 65, 3, 65, 697, 8, 65, 1, 65,
		1, 65, 1, 65, 3, 65, 702, 8, 65, 3, 65, 704, 8, 65, 1, 66, 1, 66, 1, 66,
		1, 67, 1, 67, 1, 67, 1, 67, 5, 67, 713, 8, 67, 10, 67, 12, 67, 716, 9,
		67, 1, 68, 1, 68, 1, 68, 5, 68, 721, 8, 68, 10, 68, 12, 68, 724, 9, 68,
		1, 69, 1, 69, 1, 69, 3, 69, 729, 8, 69, 1, 70, 1, 70, 1, 71, 1, 71, 1,
		71, 1, 71, 1, 71, 3, 71, 738, 8, 71, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72,
		3, 72, 745, 8, 72, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 752, 8, 73,
		1, 74, 1, 74, 1, 75, 1, 75, 1, 76, 1, 76, 1, 77, 1, 77, 1, 77, 1, 77, 1,
		77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 3, 77, 772, 8, 77,
		1, 78, 1, 78, 1, 78, 3, 78, 777, 8, 78, 1, 78, 1, 78, 5, 78, 781, 8, 78,
		10, 78, 12, 78, 784, 9, 78, 1, 79, 1, 79, 3, 79, 788, 8, 79, 1, 80, 1,
		80, 4, 80, 792, 8, 80, 11, 80, 12, 80, 793, 1, 80, 3, 80, 797, 8, 80, 1,
		80, 3, 80, 800, 8, 80, 1, 81, 3, 81, 803, 8, 81, 1, 81, 1, 81, 3, 81, 807,
		8, 81, 1, 82, 1, 82, 1, 82, 1, 82, 1, 83, 1, 83, 3, 83, 815, 8, 83, 1,
		84, 1, 84, 1, 85, 1, 85, 1, 86, 1, 86, 1, 87, 1, 87, 3, 87, 825, 8, 87,
		1, 88, 1, 88, 1, 89, 1, 89, 1, 89, 1, 89, 3, 89, 833, 8, 89, 1, 90, 1,
		90, 1, 90, 0, 0, 91, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26,
		28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62,
		64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98,
		100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128,
		130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158,
		160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 0, 14, 2, 0, 62,
		62, 73, 73, 2, 0, 78, 78, 80, 80, 2, 0, 79, 79, 81, 81, 2, 0, 1, 4, 6,
		12, 1, 0, 58, 59, 2, 0, 82, 82, 84, 84, 2, 0, 83, 83, 85, 85, 1, 0, 44,
		45, 2, 0, 53, 53, 73, 73, 1, 0, 25, 30, 1, 0, 32, 35, 1, 0, 61, 62, 1,
		0, 42, 43, 3, 0, 26, 31, 36, 49, 52, 52, 898, 0, 185, 1, 0, 0, 0, 2, 202,
		1, 0, 0, 0, 4, 204, 1, 0, 0, 0, 6, 209, 1, 0, 0, 0, 8, 222, 1, 0, 0, 0,
		10, 237, 1, 0, 0, 0, 12, 252, 1, 0, 0, 0, 14, 270, 1, 0, 0, 0, 16, 282,
		1, 0, 0, 0, 18, 287, 1, 0, 0, 0, 20, 289, 1, 0, 0, 0, 22, 307, 1, 0, 0,
		0, 24, 312, 1, 0, 0, 0, 26, 314, 1, 0, 0, 0, 28, 332, 1, 0, 0, 0, 30, 337,
		1, 0, 0, 0, 32, 339, 1, 0, 0, 0, 34, 356, 1, 0, 0, 0, 36, 363, 1, 0, 0,
		0, 38, 365, 1, 0, 0, 0, 40, 382, 1, 0, 0, 0, 42, 387, 1, 0, 0, 0, 44, 389,
		1, 0, 0, 0, 46, 404, 1, 0, 0, 0, 48, 406, 1, 0, 0, 0, 50, 410, 1, 0, 0,
		0, 52, 419, 1, 0, 0, 0, 54, 421, 1, 0, 0, 0, 56, 423, 1, 0, 0, 0, 58, 430,
		1, 0, 0, 0, 60, 449, 1, 0, 0, 0, 62, 454, 1, 0, 0, 0, 64, 456, 1, 0, 0,
		0, 66, 459, 1, 0, 0, 0, 68, 462, 1, 0, 0, 0, 70, 465, 1, 0, 0, 0, 72, 468,
		1, 0, 0, 0, 74, 471, 1, 0, 0, 0, 76, 474, 1, 0, 0, 0, 78, 477, 1, 0, 0,
		0, 80, 480, 1, 0, 0, 0, 82, 483, 1, 0, 0, 0, 84, 486, 1, 0, 0, 0, 86, 489,
		1, 0, 0, 0, 88, 498, 1, 0, 0, 0, 90, 500, 1, 0, 0, 0, 92, 502, 1, 0, 0,
		0, 94, 511, 1, 0, 0, 0, 96, 520, 1, 0, 0, 0, 98, 534, 1, 0, 0, 0, 100,
		541, 1, 0, 0, 0, 102, 548, 1, 0, 0, 0, 104, 559, 1, 0, 0, 0, 106, 570,
		1, 0, 0, 0, 108, 583, 1, 0, 0, 0, 110, 591, 1, 0, 0, 0, 112, 602, 1, 0,
		0, 0, 114, 614, 1, 0, 0, 0, 116, 623, 1, 0, 0, 0, 118, 635, 1, 0, 0, 0,
		120, 650, 1, 0, 0, 0, 122, 671, 1, 0, 0, 0, 124, 674, 1, 0, 0, 0, 126,
		682, 1, 0, 0, 0, 128, 686, 1, 0, 0, 0, 130, 692, 1, 0, 0, 0, 132, 705,
		1, 0, 0, 0, 134, 708, 1, 0, 0, 0, 136, 717, 1, 0, 0, 0, 138, 725, 1, 0,
		0, 0, 140, 730, 1, 0, 0, 0, 142, 737, 1, 0, 0, 0, 144, 744, 1, 0, 0, 0,
		146, 751, 1, 0, 0, 0, 148, 753, 1, 0, 0, 0, 150, 755, 1, 0, 0, 0, 152,
		757, 1, 0, 0, 0, 154, 771, 1, 0, 0, 0, 156, 773, 1, 0, 0, 0, 158, 785,
		1, 0, 0, 0, 160, 789, 1, 0, 0, 0, 162, 802, 1, 0, 0, 0, 164, 808, 1, 0,
		0, 0, 166, 812, 1, 0, 0, 0, 168, 816, 1, 0, 0, 0, 170, 818, 1, 0, 0, 0,
		172, 820, 1, 0, 0, 0, 174, 824, 1, 0, 0, 0, 176, 826, 1, 0, 0, 0, 178,
		832, 1, 0, 0, 0, 180, 834, 1, 0, 0, 0, 182, 184, 3, 2, 1, 0, 183, 182,
		1, 0, 0, 0, 184, 187, 1, 0, 0, 0, 185, 183, 1, 0, 0, 0, 185, 186, 1, 0,
		0, 0, 186, 188, 1, 0, 0, 0, 187, 185, 1, 0, 0, 0, 188, 189, 5, 0, 0, 1,
		189, 1, 1, 0, 0, 0, 190, 203, 3, 4, 2, 0, 191, 203, 3, 6, 3, 0, 192, 203,
		3, 8, 4, 0, 193, 203, 3, 26, 13, 0, 194, 203, 3, 20, 10, 0, 195, 203, 3,
		32, 16, 0, 196, 203, 3, 38, 19, 0, 197, 203, 3, 44, 22, 0, 198, 203, 3,
		48, 24, 0, 199, 203, 3, 58, 29, 0, 200, 203, 3, 10, 5, 0, 201, 203, 3,
		12, 6, 0, 202, 190, 1, 0, 0, 0, 202, 191, 1, 0, 0, 0, 202, 192, 1, 0, 0,
		0, 202, 193, 1, 0, 0, 0, 202, 194, 1, 0, 0, 0, 202, 195, 1, 0, 0, 0, 202,
		196, 1, 0, 0, 0, 202, 197, 1, 0, 0, 0, 202, 198, 1, 0, 0, 0, 202, 199,
		1, 0, 0, 0, 202, 200, 1, 0, 0, 0, 202, 201, 1, 0, 0, 0, 203, 3, 1, 0, 0,
		0, 204, 205, 5, 1, 0, 0, 205, 206, 3, 144, 72, 0, 206, 207, 5, 53, 0, 0,
		207, 208, 7, 0, 0, 0, 208, 5, 1, 0, 0, 0, 209, 210, 5, 2, 0, 0, 210, 212,
		3, 144, 72, 0, 211, 213, 3, 14, 7, 0, 212, 211, 1, 0, 0, 0, 213, 214, 1,
		0, 0, 0, 214, 212, 1, 0, 0, 0, 214, 215, 1, 0, 0, 0, 215, 219, 1, 0, 0,
		0, 216, 218, 3, 16, 8, 0, 217, 216, 1, 0, 0, 0, 218, 221, 1, 0, 0, 0, 219,
		217, 1, 0, 0, 0, 219, 220, 1, 0, 0, 0, 220, 7, 1, 0, 0, 0, 221, 219, 1,
		0, 0, 0, 222, 223, 5, 3, 0, 0, 223, 228, 3, 144, 72, 0, 224, 227, 3, 14,
		7, 0, 225, 227, 3, 86, 43, 0, 226, 224, 1, 0, 0, 0, 226, 225, 1, 0, 0,
		0, 227, 230, 1, 0, 0, 0, 228, 226, 1, 0, 0, 0, 228, 229, 1, 0, 0, 0, 229,
		234, 1, 0, 0, 0, 230, 228, 1, 0, 0, 0, 231, 233, 3, 16, 8, 0, 232, 231,
		1, 0, 0, 0, 233, 236, 1, 0, 0, 0, 234, 232, 1, 0, 0, 0, 234, 235, 1, 0,
		0, 0, 235, 9, 1, 0, 0, 0, 236, 234, 1, 0, 0, 0, 237, 238, 5, 11, 0, 0,
		238, 243, 3, 144, 72, 0, 239, 242, 3, 14, 7, 0, 240, 242, 3, 92, 46, 0,
		241, 239, 1, 0, 0, 0, 241, 240, 1, 0, 0, 0, 242, 245, 1, 0, 0, 0, 243,
		241, 1, 0, 0, 0, 243, 244, 1, 0, 0, 0, 244, 249, 1, 0, 0, 0, 245, 243,
		1, 0, 0, 0, 246, 248, 3, 18, 9, 0, 247, 246, 1, 0, 0, 0, 248, 251, 1, 0,
		0, 0, 249, 247, 1, 0, 0, 0, 249, 250, 1, 0, 0, 0, 250, 11, 1, 0, 0, 0,
		251, 249, 1, 0, 0, 0, 252, 253, 5, 12, 0, 0, 253, 257, 3, 144, 72, 0, 254,
		256, 3, 14, 7, 0, 255, 254, 1, 0, 0, 0, 256, 259, 1, 0, 0, 0, 257, 255,
		1, 0, 0, 0, 257, 258, 1, 0, 0, 0, 258, 263, 1, 0, 0, 0, 259, 257, 1, 0,
		0, 0, 260, 262, 3, 18, 9, 0, 261, 260, 1, 0, 0, 0, 262, 265, 1, 0, 0, 0,
		263, 261, 1, 0, 0, 0, 263, 264, 1, 0, 0, 0, 264, 13, 1, 0, 0, 0, 265, 263,
		1, 0, 0, 0, 266, 271, 3, 64, 32, 0, 267, 271, 3, 66, 33, 0, 268, 271, 3,
		68, 34, 0, 269, 271, 3, 70, 35, 0, 270, 266, 1, 0, 0, 0, 270, 267, 1, 0,
		0, 0, 270, 268, 1, 0, 0, 0, 270, 269, 1, 0, 0, 0, 271, 15, 1, 0, 0, 0,
		272, 283, 3, 94, 47, 0, 273, 283, 3, 96, 48, 0, 274, 283, 3, 98, 49, 0,
		275, 283, 3, 100, 50, 0, 276, 283, 3, 102, 51, 0, 277, 283, 3, 104, 52,
		0, 278, 283, 3, 106, 53, 0, 279, 283, 3, 108, 54, 0, 280, 283, 3, 114,
		57, 0, 281, 283, 3, 122, 61, 0, 282, 272, 1, 0, 0, 0, 282, 273, 1, 0, 0,
		0, 282, 274, 1, 0, 0, 0, 282, 275, 1, 0, 0, 0, 282, 276, 1, 0, 0, 0, 282,
		277, 1, 0, 0, 0, 282, 278, 1, 0, 0, 0, 282, 279, 1, 0, 0, 0, 282, 280,
		1, 0, 0, 0, 282, 281, 1, 0, 0, 0, 283, 17, 1, 0, 0, 0, 284, 288, 3, 16,
		8, 0, 285, 288, 3, 120, 60, 0, 286, 288, 3, 118, 59, 0, 287, 284, 1, 0,
		0, 0, 287, 285, 1, 0, 0, 0, 287, 286, 1, 0, 0, 0, 288, 19, 1, 0, 0, 0,
		289, 290, 5, 4, 0, 0, 290, 294, 3, 144, 72, 0, 291, 293, 3, 22, 11, 0,
		292, 291, 1, 0, 0, 0, 293, 296, 1, 0, 0, 0, 294, 292, 1, 0, 0, 0, 294,
		295, 1, 0, 0, 0, 295, 300, 1, 0, 0, 0, 296, 294, 1, 0, 0, 0, 297, 299,
		3, 24, 12, 0, 298, 297, 1, 0, 0, 0, 299, 302, 1, 0, 0, 0, 300, 298, 1,
		0, 0, 0, 300, 301, 1, 0, 0, 0, 301, 21, 1, 0, 0, 0, 302, 300, 1, 0, 0,
		0, 303, 308, 3, 78, 39, 0, 304, 308, 3, 68, 34, 0, 305, 308, 3, 70, 35,
		0, 306, 308, 3, 80, 40, 0, 307, 303, 1, 0, 0, 0, 307, 304, 1, 0, 0, 0,
		307, 305, 1, 0, 0, 0, 307, 306, 1, 0, 0, 0, 308, 23, 1, 0, 0, 0, 309, 313,
		3, 100, 50, 0, 310, 313, 3, 114, 57, 0, 311, 313, 3, 122, 61, 0, 312, 309,
		1, 0, 0, 0, 312, 310, 1, 0, 0, 0, 312, 311, 1, 0, 0, 0, 313, 25, 1, 0,
		0, 0, 314, 315, 5, 6, 0, 0, 315, 319, 3, 144, 72, 0, 316, 318, 3, 28, 14,
		0, 317, 316, 1, 0, 0, 0, 318, 321, 1, 0, 0, 0, 319, 317, 1, 0, 0, 0, 319,
		320, 1, 0, 0, 0, 320, 325, 1, 0, 0, 0, 321, 319, 1, 0, 0, 0, 322, 324,
		3, 30, 15, 0, 323, 322, 1, 0, 0, 0, 324, 327, 1, 0, 0, 0, 325, 323, 1,
		0, 0, 0, 325, 326, 1, 0, 0, 0, 326, 27, 1, 0, 0, 0, 327, 325, 1, 0, 0,
		0, 328, 333, 3, 70, 35, 0, 329, 333, 3, 72, 36, 0, 330, 333, 3, 74, 37,
		0, 331, 333, 3, 76, 38, 0, 332, 328, 1, 0, 0, 0, 332, 329, 1, 0, 0, 0,
		332, 330, 1, 0, 0, 0, 332, 331, 1, 0, 0, 0, 333, 29, 1, 0, 0, 0, 334, 338,
		3, 100, 50, 0, 335, 338, 3, 114, 57, 0, 336, 338, 3, 122, 61, 0, 337, 334,
		1, 0, 0, 0, 337, 335, 1, 0, 0, 0, 337, 336, 1, 0, 0, 0, 338, 31, 1, 0,
		0, 0, 339, 340, 5, 7, 0, 0, 340, 344, 3, 144, 72, 0, 341, 343, 3, 34, 17,
		0, 342, 341, 1, 0, 0, 0, 343, 346, 1, 0, 0, 0, 344, 342, 1, 0, 0, 0, 344,
		345, 1, 0, 0, 0, 345, 350, 1, 0, 0, 0, 346, 344, 1, 0, 0, 0, 347, 349,
		3, 36, 18, 0, 348, 347, 1, 0, 0, 0, 349, 352, 1, 0, 0, 0, 350, 348, 1,
		0, 0, 0, 350, 351, 1, 0, 0, 0, 351, 33, 1, 0, 0, 0, 352, 350, 1, 0, 0,
		0, 353, 357, 3, 66, 33, 0, 354, 357, 3, 68, 34, 0, 355, 357, 3, 70, 35,
		0, 356, 353, 1, 0, 0, 0, 356, 354, 1, 0, 0, 0, 356, 355, 1, 0, 0, 0, 357,
		35, 1, 0, 0, 0, 358, 364, 3, 124, 62, 0, 359, 364, 3, 108, 54, 0, 360,
		364, 3, 110, 55, 0, 361, 364, 3, 114, 57, 0, 362, 364, 3, 116, 58, 0, 363,
		358, 1, 0, 0, 0, 363, 359, 1, 0, 0, 0, 363, 360, 1, 0, 0, 0, 363, 361,
		1, 0, 0, 0, 363, 362, 1, 0, 0, 0, 364, 37, 1, 0, 0, 0, 365, 366, 5, 8,
		0, 0, 366, 370, 3, 144, 72, 0, 367, 369, 3, 40, 20, 0, 368, 367, 1, 0,
		0, 0, 369, 372, 1, 0, 0, 0, 370, 368, 1, 0, 0, 0, 370, 371, 1, 0, 0, 0,
		371, 376, 1, 0, 0, 0, 372, 370, 1, 0, 0, 0, 373, 375, 3, 42, 21, 0, 374,
		373, 1, 0, 0, 0, 375, 378, 1, 0, 0, 0, 376, 374, 1, 0, 0, 0, 376, 377,
		1, 0, 0, 0, 377, 39, 1, 0, 0, 0, 378, 376, 1, 0, 0, 0, 379, 383, 3, 66,
		33, 0, 380, 383, 3, 68, 34, 0, 381, 383, 3, 70, 35, 0, 382, 379, 1, 0,
		0, 0, 382, 380, 1, 0, 0, 0, 382, 381, 1, 0, 0, 0, 383, 41, 1, 0, 0, 0,
		384, 388, 3, 160, 80, 0, 385, 388, 3, 110, 55, 0, 386, 388, 3, 116, 58,
		0, 387, 384, 1, 0, 0, 0, 387, 385, 1, 0, 0, 0, 387, 386, 1, 0, 0, 0, 388,
		43, 1, 0, 0, 0, 389, 390, 5, 9, 0, 0, 390, 392, 5, 77, 0, 0, 391, 393,
		3, 46, 23, 0, 392, 391, 1, 0, 0, 0, 393, 394, 1, 0, 0, 0, 394, 392, 1,
		0, 0, 0, 394, 395, 1, 0, 0, 0, 395, 45, 1, 0, 0, 0, 396, 405, 3, 16, 8,
		0, 397, 405, 3, 120, 60, 0, 398, 405, 3, 118, 59, 0, 399, 405, 3, 160,
		80, 0, 400, 405, 3, 110, 55, 0, 401, 405, 3, 116, 58, 0, 402, 405, 3, 124,
		62, 0, 403, 405, 3, 112, 56, 0, 404, 396, 1, 0, 0, 0, 404, 397, 1, 0, 0,
		0, 404, 398, 1, 0, 0, 0, 404, 399, 1, 0, 0, 0, 404, 400, 1, 0, 0, 0, 404,
		401, 1, 0, 0, 0, 404, 402, 1, 0, 0, 0, 404, 403, 1, 0, 0, 0, 405, 47, 1,
		0, 0, 0, 406, 407, 5, 9, 0, 0, 407, 408, 3, 50, 25, 0, 408, 409, 3, 56,
		28, 0, 409, 49, 1, 0, 0, 0, 410, 414, 5, 76, 0, 0, 411, 413, 3, 52, 26,
		0, 412, 411, 1, 0, 0, 0, 413, 416, 1, 0, 0, 0, 414, 412, 1, 0, 0, 0, 414,
		415, 1, 0, 0, 0, 415, 417, 1, 0, 0, 0, 416, 414, 1, 0, 0, 0, 417, 418,
		3, 54, 27, 0, 418, 51, 1, 0, 0, 0, 419, 420, 7, 1, 0, 0, 420, 53, 1, 0,
		0, 0, 421, 422, 7, 2, 0, 0, 422, 55, 1, 0, 0, 0, 423, 427, 5, 54, 0, 0,
		424, 426, 8, 3, 0, 0, 425, 424, 1, 0, 0, 0, 426, 429, 1, 0, 0, 0, 427,
		425, 1, 0, 0, 0, 427, 428, 1, 0, 0, 0, 428, 57, 1, 0, 0, 0, 429, 427, 1,
		0, 0, 0, 430, 431, 5, 10, 0, 0, 431, 435, 3, 144, 72, 0, 432, 434, 3, 60,
		30, 0, 433, 432, 1, 0, 0, 0, 434, 437, 1, 0, 0, 0, 435, 433, 1, 0, 0, 0,
		435, 436, 1, 0, 0, 0, 436, 441, 1, 0, 0, 0, 437, 435, 1, 0, 0, 0, 438,
		440, 3, 62, 31, 0, 439, 438, 1, 0, 0, 0, 440, 443, 1, 0, 0, 0, 441, 439,
		1, 0, 0, 0, 441, 442, 1, 0, 0, 0, 442, 59, 1, 0, 0, 0, 443, 441, 1, 0,
		0, 0, 444, 450, 3, 66, 33, 0, 445, 450, 3, 82, 41, 0, 446, 450, 3, 84,
		42, 0, 447, 450, 3, 70, 35, 0, 448, 450, 3, 68, 34, 0, 449, 444, 1, 0,
		0, 0, 449, 445, 1, 0, 0, 0, 449, 446, 1, 0, 0, 0, 449, 447, 1, 0, 0, 0,
		449, 448, 1, 0, 0, 0, 450, 61, 1, 0, 0, 0, 451, 455, 3, 112, 56, 0, 452,
		455, 3, 114, 57, 0, 453, 455, 3, 122, 61, 0, 454, 451, 1, 0, 0, 0, 454,
		452, 1, 0, 0, 0, 454, 453, 1, 0, 0, 0, 455, 63, 1, 0, 0, 0, 456, 457, 5,
		13, 0, 0, 457, 458, 3, 144, 72, 0, 458, 65, 1, 0, 0, 0, 459, 460, 5, 14,
		0, 0, 460, 461, 3, 144, 72, 0, 461, 67, 1, 0, 0, 0, 462, 463, 5, 15, 0,
		0, 463, 464, 5, 58, 0, 0, 464, 69, 1, 0, 0, 0, 465, 466, 5, 16, 0, 0, 466,
		467, 7, 4, 0, 0, 467, 71, 1, 0, 0, 0, 468, 469, 5, 17, 0, 0, 469, 470,
		5, 58, 0, 0, 470, 73, 1, 0, 0, 0, 471, 472, 5, 18, 0, 0, 472, 473, 5, 58,
		0, 0, 473, 75, 1, 0, 0, 0, 474, 475, 5, 19, 0, 0, 475, 476, 5, 62, 0, 0,
		476, 77, 1, 0, 0, 0, 477, 478, 5, 5, 0, 0, 478, 479, 3, 144, 72, 0, 479,
		79, 1, 0, 0, 0, 480, 481, 5, 20, 0, 0, 481, 482, 5, 62, 0, 0, 482, 81,
		1, 0, 0, 0, 483, 484, 5, 21, 0, 0, 484, 485, 3, 144, 72, 0, 485, 83, 1,
		0, 0, 0, 486, 487, 5, 22, 0, 0, 487, 488, 5, 58, 0, 0, 488, 85, 1, 0, 0,
		0, 489, 493, 5, 23, 0, 0, 490, 492, 3, 88, 44, 0, 491, 490, 1, 0, 0, 0,
		492, 495, 1, 0, 0, 0, 493, 491, 1, 0, 0, 0, 493, 494, 1, 0, 0, 0, 494,
		496, 1, 0, 0, 0, 495, 493, 1, 0, 0, 0, 496, 497, 3, 90, 45, 0, 497, 87,
		1, 0, 0, 0, 498, 499, 7, 5, 0, 0, 499, 89, 1, 0, 0, 0, 500, 501, 7, 6,
		0, 0, 501, 91, 1, 0, 0, 0, 502, 506, 5, 24, 0, 0, 503, 505, 5, 87, 0, 0,
		504, 503, 1, 0, 0, 0, 505, 508, 1, 0, 0, 0, 506, 504, 1, 0, 0, 0, 506,
		507, 1, 0, 0, 0, 507, 509, 1, 0, 0, 0, 508, 506, 1, 0, 0, 0, 509, 510,
		5, 88, 0, 0, 510, 93, 1, 0, 0, 0, 511, 512, 5, 54, 0, 0, 512, 513, 3, 146,
		73, 0, 513, 517, 5, 66, 0, 0, 514, 516, 3, 150, 75, 0, 515, 514, 1, 0,
		0, 0, 516, 519, 1, 0, 0, 0, 517, 515, 1, 0, 0, 0, 517, 518, 1, 0, 0, 0,
		518, 95, 1, 0, 0, 0, 519, 517, 1, 0, 0, 0, 520, 521, 5, 54, 0, 0, 521,
		526, 3, 146, 73, 0, 522, 523, 5, 38, 0, 0, 523, 525, 3, 146, 73, 0, 524,
		522, 1, 0, 0, 0, 525, 528, 1, 0, 0, 0, 526, 524, 1, 0, 0, 0, 526, 527,
		1, 0, 0, 0, 527, 530, 1, 0, 0, 0, 528, 526, 1, 0, 0, 0, 529, 531, 3, 150,
		75, 0, 530, 529, 1, 0, 0, 0, 531, 532, 1, 0, 0, 0, 532, 530, 1, 0, 0, 0,
		532, 533, 1, 0, 0, 0, 533, 97, 1, 0, 0, 0, 534, 535, 5, 54, 0, 0, 535,
		536, 3, 146, 73, 0, 536, 537, 5, 31, 0, 0, 537, 539, 3, 144, 72, 0, 538,
		540, 3, 152, 76, 0, 539, 538, 1, 0, 0, 0, 539, 540, 1, 0, 0, 0, 540, 99,
		1, 0, 0, 0, 541, 542, 5, 54, 0, 0, 542, 543, 3, 146, 73, 0, 543, 544, 5,
		53, 0, 0, 544, 546, 3, 154, 77, 0, 545, 547, 5, 50, 0, 0, 546, 545, 1,
		0, 0, 0, 546, 547, 1, 0, 0, 0, 547, 101, 1, 0, 0, 0, 548, 549, 5, 54, 0,
		0, 549, 550, 3, 146, 73, 0, 550, 551, 5, 36, 0, 0, 551, 556, 3, 156, 78,
		0, 552, 553, 5, 38, 0, 0, 553, 555, 3, 156, 78, 0, 554, 552, 1, 0, 0, 0,
		555, 558, 1, 0, 0, 0, 556, 554, 1, 0, 0, 0, 556, 557, 1, 0, 0, 0, 557,
		103, 1, 0, 0, 0, 558, 556, 1, 0, 0, 0, 559, 560, 5, 54, 0, 0, 560, 561,
		3, 146, 73, 0, 561, 562, 5, 39, 0, 0, 562, 567, 3, 178, 89, 0, 563, 564,
		5, 40, 0, 0, 564, 566, 3, 178, 89, 0, 565, 563, 1, 0, 0, 0, 566, 569, 1,
		0, 0, 0, 567, 565, 1, 0, 0, 0, 567, 568, 1, 0, 0, 0, 568, 105, 1, 0, 0,
		0, 569, 567, 1, 0, 0, 0, 570, 572, 5, 54, 0, 0, 571, 573, 3, 146, 73, 0,
		572, 571, 1, 0, 0, 0, 572, 573, 1, 0, 0, 0, 573, 574, 1, 0, 0, 0, 574,
		575, 5, 41, 0, 0, 575, 580, 3, 144, 72, 0, 576, 577, 5, 38, 0, 0, 577,
		579, 3, 144, 72, 0, 578, 576, 1, 0, 0, 0, 579, 582, 1, 0, 0, 0, 580, 578,
		1, 0, 0, 0, 580, 581, 1, 0, 0, 0, 581, 107, 1, 0, 0, 0, 582, 580, 1, 0,
		0, 0, 583, 585, 5, 54, 0, 0, 584, 586, 3, 146, 73, 0, 585, 584, 1, 0, 0,
		0, 585, 586, 1, 0, 0, 0, 586, 587, 1, 0, 0, 0, 587, 588, 3, 148, 74, 0,
		588, 589, 5, 53, 0, 0, 589, 590, 3, 154, 77, 0, 590, 109, 1, 0, 0, 0, 591,
		595, 5, 54, 0, 0, 592, 594, 5, 62, 0, 0, 593, 592, 1, 0, 0, 0, 594, 597,
		1, 0, 0, 0, 595, 593, 1, 0, 0, 0, 595, 596, 1, 0, 0, 0, 596, 598, 1, 0,
		0, 0, 597, 595, 1, 0, 0, 0, 598, 599, 3, 148, 74, 0, 599, 600, 5, 53, 0,
		0, 600, 601, 3, 154, 77, 0, 601, 111, 1, 0, 0, 0, 602, 604, 5, 54, 0, 0,
		603, 605, 3, 146, 73, 0, 604, 603, 1, 0, 0, 0, 604, 605, 1, 0, 0, 0, 605,
		606, 1, 0, 0, 0, 606, 607, 5, 57, 0, 0, 607, 609, 5, 58, 0, 0, 608, 610,
		5, 58, 0, 0, 609, 608, 1, 0, 0, 0, 609, 610, 1, 0, 0, 0, 610, 612, 1, 0,
		0, 0, 611, 613, 5, 62, 0, 0, 612, 611, 1, 0, 0, 0, 612, 613, 1, 0, 0, 0,
		613, 113, 1, 0, 0, 0, 614, 616, 5, 54, 0, 0, 615, 617, 3, 146, 73, 0, 616,
		615, 1, 0, 0, 0, 616, 617, 1, 0, 0, 0, 617, 618, 1, 0, 0, 0, 618, 621,
		5, 51, 0, 0, 619, 622, 5, 77, 0, 0, 620, 622, 3, 50, 25, 0, 621, 619, 1,
		0, 0, 0, 621, 620, 1, 0, 0, 0, 622, 115, 1, 0, 0, 0, 623, 627, 5, 54, 0,
		0, 624, 626, 5, 62, 0, 0, 625, 624, 1, 0, 0, 0, 626, 629, 1, 0, 0, 0, 627,
		625, 1, 0, 0, 0, 627, 628, 1, 0, 0, 0, 628, 630, 1, 0, 0, 0, 629, 627,
		1, 0, 0, 0, 630, 633, 5, 51, 0, 0, 631, 634, 5, 77, 0, 0, 632, 634, 3,
		50, 25, 0, 633, 631, 1, 0, 0, 0, 633, 632, 1, 0, 0, 0, 634, 117, 1, 0,
		0, 0, 635, 636, 5, 54, 0, 0, 636, 637, 3, 146, 73, 0, 637, 641, 5, 66,
		0, 0, 638, 640, 3, 150, 75, 0, 639, 638, 1, 0, 0, 0, 640, 643, 1, 0, 0,
		0, 641, 639, 1, 0, 0, 0, 641, 642, 1, 0, 0, 0, 642, 644, 1, 0, 0, 0, 643,
		641, 1, 0, 0, 0, 644, 645, 5, 52, 0, 0, 645, 646, 7, 0, 0, 0, 646, 648,
		5, 58, 0, 0, 647, 649, 7, 4, 0, 0, 648, 647, 1, 0, 0, 0, 648, 649, 1, 0,
		0, 0, 649, 119, 1, 0, 0, 0, 650, 651, 5, 54, 0, 0, 651, 652, 3, 146, 73,
		0, 652, 656, 5, 66, 0, 0, 653, 655, 3, 150, 75, 0, 654, 653, 1, 0, 0, 0,
		655, 658, 1, 0, 0, 0, 656, 654, 1, 0, 0, 0, 656, 657, 1, 0, 0, 0, 657,
		659, 1, 0, 0, 0, 658, 656, 1, 0, 0, 0, 659, 664, 3, 178, 89, 0, 660, 661,
		5, 40, 0, 0, 661, 663, 3, 178, 89, 0, 662, 660, 1, 0, 0, 0, 663, 666, 1,
		0, 0, 0, 664, 662, 1, 0, 0, 0, 664, 665, 1, 0, 0, 0, 665, 667, 1, 0, 0,
		0, 666, 664, 1, 0, 0, 0, 667, 669, 5, 58, 0, 0, 668, 670, 7, 4, 0, 0, 669,
		668, 1, 0, 0, 0, 669, 670, 1, 0, 0, 0, 670, 121, 1, 0, 0, 0, 671, 672,
		5, 54, 0, 0, 672, 673, 3, 146, 73, 0, 673, 123, 1, 0, 0, 0, 674, 676, 5,
		54, 0, 0, 675, 677, 7, 7, 0, 0, 676, 675, 1, 0, 0, 0, 676, 677, 1, 0, 0,
		0, 677, 680, 1, 0, 0, 0, 678, 681, 3, 126, 63, 0, 679, 681, 3, 128, 64,
		0, 680, 678, 1, 0, 0, 0, 680, 679, 1, 0, 0, 0, 681, 125, 1, 0, 0, 0, 682,
		684, 3, 158, 79, 0, 683, 685, 3, 130, 65, 0, 684, 683, 1, 0, 0, 0, 684,
		685, 1, 0, 0, 0, 685, 127, 1, 0, 0, 0, 686, 687, 5, 46, 0, 0, 687, 690,
		3, 130, 65, 0, 688, 689, 5, 47, 0, 0, 689, 691, 3, 136, 68, 0, 690, 688,
		1, 0, 0, 0, 690, 691, 1, 0, 0, 0, 691, 129, 1, 0, 0, 0, 692, 703, 5, 31,
		0, 0, 693, 696, 3, 132, 66, 0, 694, 695, 5, 38, 0, 0, 695, 697, 3, 134,
		67, 0, 696, 694, 1, 0, 0, 0, 696, 697, 1, 0, 0, 0, 697, 704, 1, 0, 0, 0,
		698, 701, 3, 134, 67, 0, 699, 700, 5, 38, 0, 0, 700, 702, 3, 132, 66, 0,
		701, 699, 1, 0, 0, 0, 701, 702, 1, 0, 0, 0, 702, 704, 1, 0, 0, 0, 703,
		693, 1, 0, 0, 0, 703, 698, 1, 0, 0, 0, 704, 131, 1, 0, 0, 0, 705, 706,
		5, 49, 0, 0, 706, 707, 3, 144, 72, 0, 707, 133, 1, 0, 0, 0, 708, 709, 5,
		48, 0, 0, 709, 714, 3, 144, 72, 0, 710, 711, 5, 38, 0, 0, 711, 713, 3,
		144, 72, 0, 712, 710, 1, 0, 0, 0, 713, 716, 1, 0, 0, 0, 714, 712, 1, 0,
		0, 0, 714, 715, 1, 0, 0, 0, 715, 135, 1, 0, 0, 0, 716, 714, 1, 0, 0, 0,
		717, 722, 3, 138, 69, 0, 718, 719, 5, 38, 0, 0, 719, 721, 3, 138, 69, 0,
		720, 718, 1, 0, 0, 0, 721, 724, 1, 0, 0, 0, 722, 720, 1, 0, 0, 0, 722,
		723, 1, 0, 0, 0, 723, 137, 1, 0, 0, 0, 724, 722, 1, 0, 0, 0, 725, 726,
		3, 144, 72, 0, 726, 728, 3, 140, 70, 0, 727, 729, 3, 142, 71, 0, 728, 727,
		1, 0, 0, 0, 728, 729, 1, 0, 0, 0, 729, 139, 1, 0, 0, 0, 730, 731, 7, 8,
		0, 0, 731, 141, 1, 0, 0, 0, 732, 738, 3, 158, 79, 0, 733, 738, 5, 42, 0,
		0, 734, 738, 5, 43, 0, 0, 735, 738, 5, 71, 0, 0, 736, 738, 5, 58, 0, 0,
		737, 732, 1, 0, 0, 0, 737, 733, 1, 0, 0, 0, 737, 734, 1, 0, 0, 0, 737,
		735, 1, 0, 0, 0, 737, 736, 1, 0, 0, 0, 738, 143, 1, 0, 0, 0, 739, 745,
		5, 73, 0, 0, 740, 745, 5, 60, 0, 0, 741, 745, 5, 64, 0, 0, 742, 745, 5,
		65, 0, 0, 743, 745, 3, 180, 90, 0, 744, 739, 1, 0, 0, 0, 744, 740, 1, 0,
		0, 0, 744, 741, 1, 0, 0, 0, 744, 742, 1, 0, 0, 0, 744, 743, 1, 0, 0, 0,
		745, 145, 1, 0, 0, 0, 746, 752, 5, 73, 0, 0, 747, 752, 5, 60, 0, 0, 748,
		752, 5, 64, 0, 0, 749, 752, 5, 65, 0, 0, 750, 752, 3, 180, 90, 0, 751,
		746, 1, 0, 0, 0, 751, 747, 1, 0, 0, 0, 751, 748, 1, 0, 0, 0, 751, 749,
		1, 0, 0, 0, 751, 750, 1, 0, 0, 0, 752, 147, 1, 0, 0, 0, 753, 754, 5, 70,
		0, 0, 754, 149, 1, 0, 0, 0, 755, 756, 7, 9, 0, 0, 756, 151, 1, 0, 0, 0,
		757, 758, 7, 10, 0, 0, 758, 153, 1, 0, 0, 0, 759, 772, 5, 58, 0, 0, 760,
		772, 5, 59, 0, 0, 761, 772, 5, 60, 0, 0, 762, 772, 5, 64, 0, 0, 763, 772,
		5, 65, 0, 0, 764, 772, 3, 166, 83, 0, 765, 772, 3, 172, 86, 0, 766, 772,
		3, 158, 79, 0, 767, 772, 3, 162, 81, 0, 768, 772, 3, 164, 82, 0, 769, 772,
		3, 176, 88, 0, 770, 772, 3, 144, 72, 0, 771, 759, 1, 0, 0, 0, 771, 760,
		1, 0, 0, 0, 771, 761, 1, 0, 0, 0, 771, 762, 1, 0, 0, 0, 771, 763, 1, 0,
		0, 0, 771, 764, 1, 0, 0, 0, 771, 765, 1, 0, 0, 0, 771, 766, 1, 0, 0, 0,
		771, 767, 1, 0, 0, 0, 771, 768, 1, 0, 0, 0, 771, 769, 1, 0, 0, 0, 771,
		770, 1, 0, 0, 0, 772, 155, 1, 0, 0, 0, 773, 776, 3, 144, 72, 0, 774, 775,
		5, 37, 0, 0, 775, 777, 3, 144, 72, 0, 776, 774, 1, 0, 0, 0, 776, 777, 1,
		0, 0, 0, 777, 778, 1, 0, 0, 0, 778, 782, 5, 66, 0, 0, 779, 781, 3, 150,
		75, 0, 780, 779, 1, 0, 0, 0, 781, 784, 1, 0, 0, 0, 782, 780, 1, 0, 0, 0,
		782, 783, 1, 0, 0, 0, 783, 157, 1, 0, 0, 0, 784, 782, 1, 0, 0, 0, 785,
		787, 5, 62, 0, 0, 786, 788, 5, 58, 0, 0, 787, 786, 1, 0, 0, 0, 787, 788,
		1, 0, 0, 0, 788, 159, 1, 0, 0, 0, 789, 791, 5, 54, 0, 0, 790, 792, 5, 62,
		0, 0, 791, 790, 1, 0, 0, 0, 792, 793, 1, 0, 0, 0, 793, 791, 1, 0, 0, 0,
		793, 794, 1, 0, 0, 0, 794, 796, 1, 0, 0, 0, 795, 797, 5, 58, 0, 0, 796,
		795, 1, 0, 0, 0, 796, 797, 1, 0, 0, 0, 797, 799, 1, 0, 0, 0, 798, 800,
		7, 4, 0, 0, 799, 798, 1, 0, 0, 0, 799, 800, 1, 0, 0, 0, 800, 161, 1, 0,
		0, 0, 801, 803, 5, 60, 0, 0, 802, 801, 1, 0, 0, 0, 802, 803, 1, 0, 0, 0,
		803, 804, 1, 0, 0, 0, 804, 806, 7, 11, 0, 0, 805, 807, 5, 58, 0, 0, 806,
		805, 1, 0, 0, 0, 806, 807, 1, 0, 0, 0, 807, 163, 1, 0, 0, 0, 808, 809,
		3, 174, 87, 0, 809, 810, 5, 55, 0, 0, 810, 811, 3, 174, 87, 0, 811, 165,
		1, 0, 0, 0, 812, 814, 5, 67, 0, 0, 813, 815, 5, 58, 0, 0, 814, 813, 1,
		0, 0, 0, 814, 815, 1, 0, 0, 0, 815, 167, 1, 0, 0, 0, 816, 817, 5, 67, 0,
		0, 817, 169, 1, 0, 0, 0, 818, 819, 5, 68, 0, 0, 819, 171, 1, 0, 0, 0, 820,
		821, 5, 69, 0, 0, 821, 173, 1, 0, 0, 0, 822, 825, 5, 60, 0, 0, 823, 825,
		3, 162, 81, 0, 824, 822, 1, 0, 0, 0, 824, 823, 1, 0, 0, 0, 825, 175, 1,
		0, 0, 0, 826, 827, 7, 12, 0, 0, 827, 177, 1, 0, 0, 0, 828, 833, 3, 144,
		72, 0, 829, 833, 3, 168, 84, 0, 830, 833, 3, 172, 86, 0, 831, 833, 3, 170,
		85, 0, 832, 828, 1, 0, 0, 0, 832, 829, 1, 0, 0, 0, 832, 830, 1, 0, 0, 0,
		832, 831, 1, 0, 0, 0, 833, 179, 1, 0, 0, 0, 834, 835, 7, 13, 0, 0, 835,
		181, 1, 0, 0, 0, 89, 185, 202, 214, 219, 226, 228, 234, 241, 243, 249,
		257, 263, 270, 282, 287, 294, 300, 307, 312, 319, 325, 332, 337, 344, 350,
		356, 363, 370, 376, 382, 387, 394, 404, 414, 427, 435, 441, 449, 454, 493,
		506, 517, 526, 532, 539, 546, 556, 567, 572, 580, 585, 595, 604, 609, 612,
		616, 621, 627, 633, 641, 648, 656, 664, 669, 676, 680, 684, 690, 696, 701,
		703, 714, 722, 728, 737, 744, 751, 771, 776, 782, 787, 793, 796, 799, 802,
		806, 814, 824, 832,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// FSHParserInit initializes any static state used to implement FSHParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewFSHParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func FSHParserInit() {
	staticData := &FSHParserStaticData
	staticData.once.Do(fshParserInit)
}

// NewFSHParser produces a new parser instance for the optional input antlr.TokenStream.
func NewFSHParser(input antlr.TokenStream) *FSHParser {
	FSHParserInit()
	this := new(FSHParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &FSHParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "FSH.g4"

	return this
}

// FSHParser tokens.
const (
	FSHParserEOF                     = antlr.TokenEOF
	FSHParserKW_ALIAS                = 1
	FSHParserKW_PROFILE              = 2
	FSHParserKW_EXTENSION            = 3
	FSHParserKW_INSTANCE             = 4
	FSHParserKW_INSTANCEOF           = 5
	FSHParserKW_INVARIANT            = 6
	FSHParserKW_VALUESET             = 7
	FSHParserKW_CODESYSTEM           = 8
	FSHParserKW_RULESET              = 9
	FSHParserKW_MAPPING              = 10
	FSHParserKW_LOGICAL              = 11
	FSHParserKW_RESOURCE             = 12
	FSHParserKW_PARENT               = 13
	FSHParserKW_ID                   = 14
	FSHParserKW_TITLE                = 15
	FSHParserKW_DESCRIPTION          = 16
	FSHParserKW_EXPRESSION           = 17
	FSHParserKW_XPATH                = 18
	FSHParserKW_SEVERITY             = 19
	FSHParserKW_USAGE                = 20
	FSHParserKW_SOURCE               = 21
	FSHParserKW_TARGET               = 22
	FSHParserKW_CONTEXT              = 23
	FSHParserKW_CHARACTERISTICS      = 24
	FSHParserKW_MOD                  = 25
	FSHParserKW_MS                   = 26
	FSHParserKW_SU                   = 27
	FSHParserKW_TU                   = 28
	FSHParserKW_NORMATIVE            = 29
	FSHParserKW_DRAFT                = 30
	FSHParserKW_FROM                 = 31
	FSHParserKW_EXAMPLE              = 32
	FSHParserKW_PREFERRED            = 33
	FSHParserKW_EXTENSIBLE           = 34
	FSHParserKW_REQUIRED             = 35
	FSHParserKW_CONTAINS             = 36
	FSHParserKW_NAMED                = 37
	FSHParserKW_AND                  = 38
	FSHParserKW_ONLY                 = 39
	FSHParserKW_OR                   = 40
	FSHParserKW_OBEYS                = 41
	FSHParserKW_TRUE                 = 42
	FSHParserKW_FALSE                = 43
	FSHParserKW_INCLUDE              = 44
	FSHParserKW_EXCLUDE              = 45
	FSHParserKW_CODES                = 46
	FSHParserKW_WHERE                = 47
	FSHParserKW_VSREFERENCE          = 48
	FSHParserKW_SYSTEM               = 49
	FSHParserKW_EXACTLY              = 50
	FSHParserKW_INSERT               = 51
	FSHParserKW_CONTENTREFERENCE     = 52
	FSHParserEQUAL                   = 53
	FSHParserSTAR                    = 54
	FSHParserCOLON                   = 55
	FSHParserCOMMA                   = 56
	FSHParserARROW                   = 57
	FSHParserSTRING                  = 58
	FSHParserMULTILINE_STRING        = 59
	FSHParserNUMBER                  = 60
	FSHParserUNIT                    = 61
	FSHParserCODE                    = 62
	FSHParserCONCEPT_STRING          = 63
	FSHParserDATETIME                = 64
	FSHParserTIME                    = 65
	FSHParserCARD                    = 66
	FSHParserREFERENCE               = 67
	FSHParserCODEABLE_REFERENCE      = 68
	FSHParserCANONICAL               = 69
	FSHParserCARET_SEQUENCE          = 70
	FSHParserREGEX                   = 71
	FSHParserBLOCK_COMMENT           = 72
	FSHParserSEQUENCE                = 73
	FSHParserWHITESPACE              = 74
	FSHParserLINE_COMMENT            = 75
	FSHParserPARAM_RULESET_REFERENCE = 76
	FSHParserRULESET_REFERENCE       = 77
	FSHParserBRACKETED_PARAM         = 78
	FSHParserLAST_BRACKETED_PARAM    = 79
	FSHParserPLAIN_PARAM             = 80
	FSHParserLAST_PLAIN_PARAM        = 81
	FSHParserQUOTED_CONTEXT          = 82
	FSHParserLAST_QUOTED_CONTEXT     = 83
	FSHParserUNQUOTED_CONTEXT        = 84
	FSHParserLAST_UNQUOTED_CONTEXT   = 85
	FSHParserCONTEXT_WHITESPACE      = 86
	FSHParserCODE_ITEM               = 87
	FSHParserLAST_CODE_ITEM          = 88
	FSHParserCODE_LIST_WHITESPACE    = 89
)

// FSHParser rules.
const (
	FSHParserRULE_doc                   = 0
	FSHParserRULE_entity                = 1
	FSHParserRULE_alias                 = 2
	FSHParserRULE_profile               = 3
	FSHParserRULE_extension             = 4
	FSHParserRULE_logical               = 5
	FSHParserRULE_resource              = 6
	FSHParserRULE_sdMetadata            = 7
	FSHParserRULE_sdRule                = 8
	FSHParserRULE_lrRule                = 9
	FSHParserRULE_instance              = 10
	FSHParserRULE_instanceMetadata      = 11
	FSHParserRULE_instanceRule          = 12
	FSHParserRULE_invariant             = 13
	FSHParserRULE_invariantMetadata     = 14
	FSHParserRULE_invariantRule         = 15
	FSHParserRULE_valueSet              = 16
	FSHParserRULE_vsMetadata            = 17
	FSHParserRULE_vsRule                = 18
	FSHParserRULE_codeSystem            = 19
	FSHParserRULE_csMetadata            = 20
	FSHParserRULE_csRule                = 21
	FSHParserRULE_ruleSet               = 22
	FSHParserRULE_ruleSetRule           = 23
	FSHParserRULE_paramRuleSet          = 24
	FSHParserRULE_paramRuleSetRef       = 25
	FSHParserRULE_parameter             = 26
	FSHParserRULE_lastParameter         = 27
	FSHParserRULE_paramRuleSetContent   = 28
	FSHParserRULE_mapping               = 29
	FSHParserRULE_mappingMetadata       = 30
	FSHParserRULE_mappingEntityRule     = 31
	FSHParserRULE_parent                = 32
	FSHParserRULE_id                    = 33
	FSHParserRULE_title                 = 34
	FSHParserRULE_description           = 35
	FSHParserRULE_expression            = 36
	FSHParserRULE_xpath                 = 37
	FSHParserRULE_severity              = 38
	FSHParserRULE_instanceOf            = 39
	FSHParserRULE_usage                 = 40
	FSHParserRULE_source                = 41
	FSHParserRULE_target                = 42
	FSHParserRULE_context               = 43
	FSHParserRULE_contextItem           = 44
	FSHParserRULE_lastContextItem       = 45
	FSHParserRULE_characteristics       = 46
	FSHParserRULE_cardRule              = 47
	FSHParserRULE_flagRule              = 48
	FSHParserRULE_valueSetRule          = 49
	FSHParserRULE_fixedValueRule        = 50
	FSHParserRULE_containsRule          = 51
	FSHParserRULE_onlyRule              = 52
	FSHParserRULE_obeysRule             = 53
	FSHParserRULE_caretValueRule        = 54
	FSHParserRULE_codeCaretValueRule    = 55
	FSHParserRULE_mappingRule           = 56
	FSHParserRULE_insertRule            = 57
	FSHParserRULE_codeInsertRule        = 58
	FSHParserRULE_addCRElementRule      = 59
	FSHParserRULE_addElementRule        = 60
	FSHParserRULE_pathRule              = 61
	FSHParserRULE_vsComponent           = 62
	FSHParserRULE_vsConceptComponent    = 63
	FSHParserRULE_vsFilterComponent     = 64
	FSHParserRULE_vsComponentFrom       = 65
	FSHParserRULE_vsFromSystem          = 66
	FSHParserRULE_vsFromValueset        = 67
	FSHParserRULE_vsFilterList          = 68
	FSHParserRULE_vsFilterDefinition    = 69
	FSHParserRULE_vsFilterOperator      = 70
	FSHParserRULE_vsFilterValue         = 71
	FSHParserRULE_name                  = 72
	FSHParserRULE_path                  = 73
	FSHParserRULE_caretPath             = 74
	FSHParserRULE_flag                  = 75
	FSHParserRULE_strength              = 76
	FSHParserRULE_value                 = 77
	FSHParserRULE_item                  = 78
	FSHParserRULE_code                  = 79
	FSHParserRULE_concept               = 80
	FSHParserRULE_quantity              = 81
	FSHParserRULE_ratio                 = 82
	FSHParserRULE_reference             = 83
	FSHParserRULE_referenceType         = 84
	FSHParserRULE_codeableReferenceType = 85
	FSHParserRULE_canonical             = 86
	FSHParserRULE_ratioPart             = 87
	FSHParserRULE_bool                  = 88
	FSHParserRULE_targetType            = 89
	FSHParserRULE_mostAlphaKeywords     = 90
)

// IDocContext is an interface to support dynamic dispatch.
type IDocContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllEntity() []IEntityContext
	Entity(i int) IEntityContext

	// IsDocContext differentiates from other interfaces.
	IsDocContext()
}

type DocContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDocContext() *DocContext {
	var p = new(DocContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_doc
	return p
}

func InitEmptyDocContext(p *DocContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_doc
}

func (*DocContext) IsDocContext() {}

func NewDocContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DocContext {
	var p = new(DocContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_doc

	return p
}

func (s *DocContext) GetParser() antlr.Parser { return s.parser }

func (s *DocContext) EOF() antlr.TerminalNode {
	return s.GetToken(FSHParserEOF, 0)
}

func (s *DocContext) AllEntity() []IEntityContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEntityContext); ok {
			len++
		}
	}

	tst := make([]IEntityContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEntityContext); ok {
			tst[i] = t.(IEntityContext)
			i++
		}
	}

	return tst
}

func (s *DocContext) Entity(i int) IEntityContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEntityContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEntityContext)
}

func (s *DocContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DocContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DocContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitDoc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Doc() (localctx IDocContext) {
	localctx = NewDocContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, FSHParserRULE_doc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(185)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8158) != 0 {
		{
			p.SetState(182)
			p.Entity()
		}

		p.SetState(187)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(188)
		p.Match(FSHParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEntityContext is an interface to support dynamic dispatch.
type IEntityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Alias() IAliasContext
	Profile() IProfileContext
	Extension() IExtensionContext
	Invariant() IInvariantContext
	Instance() IInstanceContext
	ValueSet() IValueSetContext
	CodeSystem() ICodeSystemContext
	RuleSet() IRuleSetContext
	ParamRuleSet() IParamRuleSetContext
	Mapping() IMappingContext
	Logical() ILogicalContext
	Resource() IResourceContext

	// IsEntityContext differentiates from other interfaces.
	IsEntityContext()
}

type EntityContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntityContext() *EntityContext {
	var p = new(EntityContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_entity
	return p
}

func InitEmptyEntityContext(p *EntityContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_entity
}

func (*EntityContext) IsEntityContext() {}

func NewEntityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EntityContext {
	var p = new(EntityContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_entity

	return p
}

func (s *EntityContext) GetParser() antlr.Parser { return s.parser }

func (s *EntityContext) Alias() IAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}

func (s *EntityContext) Profile() IProfileContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProfileContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProfileContext)
}

func (s *EntityContext) Extension() IExtensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtensionContext)
}

func (s *EntityContext) Invariant() IInvariantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInvariantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInvariantContext)
}

func (s *EntityContext) Instance() IInstanceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstanceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstanceContext)
}

func (s *EntityContext) ValueSet() IValueSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueSetContext)
}

func (s *EntityContext) CodeSystem() ICodeSystemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeSystemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeSystemContext)
}

func (s *EntityContext) RuleSet() IRuleSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSetContext)
}

func (s *EntityContext) ParamRuleSet() IParamRuleSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamRuleSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamRuleSetContext)
}

func (s *EntityContext) Mapping() IMappingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMappingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMappingContext)
}

func (s *EntityContext) Logical() ILogicalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalContext)
}

func (s *EntityContext) Resource() IResourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceContext)
}

func (s *EntityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EntityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EntityContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitEntity(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Entity() (localctx IEntityContext) {
	localctx = NewEntityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, FSHParserRULE_entity)
	p.SetState(202)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(190)
			p.Alias()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(191)
			p.Profile()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(192)
			p.Extension()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(193)
			p.Invariant()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(194)
			p.Instance()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(195)
			p.ValueSet()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(196)
			p.CodeSystem()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(197)
			p.RuleSet()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(198)
			p.ParamRuleSet()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(199)
			p.Mapping()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(200)
			p.Logical()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(201)
			p.Resource()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAliasContext is an interface to support dynamic dispatch.
type IAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ALIAS() antlr.TerminalNode
	Name() INameContext
	EQUAL() antlr.TerminalNode
	SEQUENCE() antlr.TerminalNode
	CODE() antlr.TerminalNode

	// IsAliasContext differentiates from other interfaces.
	IsAliasContext()
}

type AliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasContext() *AliasContext {
	var p = new(AliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_alias
	return p
}

func InitEmptyAliasContext(p *AliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_alias
}

func (*AliasContext) IsAliasContext() {}

func NewAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasContext {
	var p = new(AliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_alias

	return p
}

func (s *AliasContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasContext) KW_ALIAS() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_ALIAS, 0)
}

func (s *AliasContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *AliasContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(FSHParserEQUAL, 0)
}

func (s *AliasContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(FSHParserSEQUENCE, 0)
}

func (s *AliasContext) CODE() antlr.TerminalNode {
	return s.GetToken(FSHParserCODE, 0)
}

func (s *AliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Alias() (localctx IAliasContext) {
	localctx = NewAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, FSHParserRULE_alias)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(204)
		p.Match(FSHParserKW_ALIAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(205)
		p.Name()
	}
	{
		p.SetState(206)
		p.Match(FSHParserEQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(207)
		_la = p.GetTokenStream().LA(1)

		if !(_la == FSHParserCODE || _la == FSHParserSEQUENCE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProfileContext is an interface to support dynamic dispatch.
type IProfileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_PROFILE() antlr.TerminalNode
	Name() INameContext
	AllSdMetadata() []ISdMetadataContext
	SdMetadata(i int) ISdMetadataContext
	AllSdRule() []ISdRuleContext
	SdRule(i int) ISdRuleContext

	// IsProfileContext differentiates from other interfaces.
	IsProfileContext()
}

type ProfileContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProfileContext() *ProfileContext {
	var p = new(ProfileContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_profile
	return p
}

func InitEmptyProfileContext(p *ProfileContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_profile
}

func (*ProfileContext) IsProfileContext() {}

func NewProfileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProfileContext {
	var p = new(ProfileContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_profile

	return p
}

func (s *ProfileContext) GetParser() antlr.Parser { return s.parser }

func (s *ProfileContext) KW_PROFILE() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_PROFILE, 0)
}

func (s *ProfileContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *ProfileContext) AllSdMetadata() []ISdMetadataContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISdMetadataContext); ok {
			len++
		}
	}

	tst := make([]ISdMetadataContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISdMetadataContext); ok {
			tst[i] = t.(ISdMetadataContext)
			i++
		}
	}

	return tst
}

func (s *ProfileContext) SdMetadata(i int) ISdMetadataContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISdMetadataContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISdMetadataContext)
}

func (s *ProfileContext) AllSdRule() []ISdRuleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISdRuleContext); ok {
			len++
		}
	}

	tst := make([]ISdRuleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISdRuleContext); ok {
			tst[i] = t.(ISdRuleContext)
			i++
		}
	}

	return tst
}

func (s *ProfileContext) SdRule(i int) ISdRuleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISdRuleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISdRuleContext)
}

func (s *ProfileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProfileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProfileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitProfile(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Profile() (localctx IProfileContext) {
	localctx = NewProfileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, FSHParserRULE_profile)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(209)
		p.Match(FSHParserKW_PROFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(210)
		p.Name()
	}
	p.SetState(212)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&122880) != 0) {
		{
			p.SetState(211)
			p.SdMetadata()
		}

		p.SetState(214)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(219)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FSHParserSTAR {
		{
			p.SetState(216)
			p.SdRule()
		}

		p.SetState(221)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExtensionContext is an interface to support dynamic dispatch.
type IExtensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_EXTENSION() antlr.TerminalNode
	Name() INameContext
	AllSdMetadata() []ISdMetadataContext
	SdMetadata(i int) ISdMetadataContext
	AllContext() []IContextContext
	Context(i int) IContextContext
	AllSdRule() []ISdRuleContext
	SdRule(i int) ISdRuleContext

	// IsExtensionContext differentiates from other interfaces.
	IsExtensionContext()
}

type ExtensionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionContext() *ExtensionContext {
	var p = new(ExtensionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_extension
	return p
}

func InitEmptyExtensionContext(p *ExtensionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_extension
}

func (*ExtensionContext) IsExtensionContext() {}

func NewExtensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionContext {
	var p = new(ExtensionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_extension

	return p
}

func (s *ExtensionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionContext) KW_EXTENSION() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_EXTENSION, 0)
}

func (s *ExtensionContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *ExtensionContext) AllSdMetadata() []ISdMetadataContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISdMetadataContext); ok {
			len++
		}
	}

	tst := make([]ISdMetadataContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISdMetadataContext); ok {
			tst[i] = t.(ISdMetadataContext)
			i++
		}
	}

	return tst
}

func (s *ExtensionContext) SdMetadata(i int) ISdMetadataContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISdMetadataContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISdMetadataContext)
}

func (s *ExtensionContext) AllContext() []IContextContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IContextContext); ok {
			len++
		}
	}

	tst := make([]IContextContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IContextContext); ok {
			tst[i] = t.(IContextContext)
			i++
		}
	}

	return tst
}

func (s *ExtensionContext) Context(i int) IContextContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContextContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContextContext)
}

func (s *ExtensionContext) AllSdRule() []ISdRuleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISdRuleContext); ok {
			len++
		}
	}

	tst := make([]ISdRuleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISdRuleContext); ok {
			tst[i] = t.(ISdRuleContext)
			i++
		}
	}

	return tst
}

func (s *ExtensionContext) SdRule(i int) ISdRuleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISdRuleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISdRuleContext)
}

func (s *ExtensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitExtension(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Extension() (localctx IExtensionContext) {
	localctx = NewExtensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, FSHParserRULE_extension)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(222)
		p.Match(FSHParserKW_EXTENSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(223)
		p.Name()
	}
	p.SetState(228)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8511488) != 0 {
		p.SetState(226)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case FSHParserKW_PARENT, FSHParserKW_ID, FSHParserKW_TITLE, FSHParserKW_DESCRIPTION:
			{
				p.SetState(224)
				p.SdMetadata()
			}

		case FSHParserKW_CONTEXT:
			{
				p.SetState(225)
				p.Context()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(230)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(234)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FSHParserSTAR {
		{
			p.SetState(231)
			p.SdRule()
		}

		p.SetState(236)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogicalContext is an interface to support dynamic dispatch.
type ILogicalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_LOGICAL() antlr.TerminalNode
	Name() INameContext
	AllSdMetadata() []ISdMetadataContext
	SdMetadata(i int) ISdMetadataContext
	AllCharacteristics() []ICharacteristicsContext
	Characteristics(i int) ICharacteristicsContext
	AllLrRule() []ILrRuleContext
	LrRule(i int) ILrRuleContext

	// IsLogicalContext differentiates from other interfaces.
	IsLogicalContext()
}

type LogicalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogicalContext() *LogicalContext {
	var p = new(LogicalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_logical
	return p
}

func InitEmptyLogicalContext(p *LogicalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_logical
}

func (*LogicalContext) IsLogicalContext() {}

func NewLogicalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalContext {
	var p = new(LogicalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_logical

	return p
}

func (s *LogicalContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalContext) KW_LOGICAL() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_LOGICAL, 0)
}

func (s *LogicalContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *LogicalContext) AllSdMetadata() []ISdMetadataContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISdMetadataContext); ok {
			len++
		}
	}

	tst := make([]ISdMetadataContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISdMetadataContext); ok {
			tst[i] = t.(ISdMetadataContext)
			i++
		}
	}

	return tst
}

func (s *LogicalContext) SdMetadata(i int) ISdMetadataContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISdMetadataContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISdMetadataContext)
}

func (s *LogicalContext) AllCharacteristics() []ICharacteristicsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICharacteristicsContext); ok {
			len++
		}
	}

	tst := make([]ICharacteristicsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICharacteristicsContext); ok {
			tst[i] = t.(ICharacteristicsContext)
			i++
		}
	}

	return tst
}

func (s *LogicalContext) Characteristics(i int) ICharacteristicsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharacteristicsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharacteristicsContext)
}

func (s *LogicalContext) AllLrRule() []ILrRuleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILrRuleContext); ok {
			len++
		}
	}

	tst := make([]ILrRuleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILrRuleContext); ok {
			tst[i] = t.(ILrRuleContext)
			i++
		}
	}

	return tst
}

func (s *LogicalContext) LrRule(i int) ILrRuleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILrRuleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILrRuleContext)
}

func (s *LogicalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitLogical(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Logical() (localctx ILogicalContext) {
	localctx = NewLogicalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, FSHParserRULE_logical)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(237)
		p.Match(FSHParserKW_LOGICAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(238)
		p.Name()
	}
	p.SetState(243)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&16900096) != 0 {
		p.SetState(241)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case FSHParserKW_PARENT, FSHParserKW_ID, FSHParserKW_TITLE, FSHParserKW_DESCRIPTION:
			{
				p.SetState(239)
				p.SdMetadata()
			}

		case FSHParserKW_CHARACTERISTICS:
			{
				p.SetState(240)
				p.Characteristics()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(245)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(249)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FSHParserSTAR {
		{
			p.SetState(246)
			p.LrRule()
		}

		p.SetState(251)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceContext is an interface to support dynamic dispatch.
type IResourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_RESOURCE() antlr.TerminalNode
	Name() INameContext
	AllSdMetadata() []ISdMetadataContext
	SdMetadata(i int) ISdMetadataContext
	AllLrRule() []ILrRuleContext
	LrRule(i int) ILrRuleContext

	// IsResourceContext differentiates from other interfaces.
	IsResourceContext()
}

type ResourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceContext() *ResourceContext {
	var p = new(ResourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_resource
	return p
}

func InitEmptyResourceContext(p *ResourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_resource
}

func (*ResourceContext) IsResourceContext() {}

func NewResourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceContext {
	var p = new(ResourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_resource

	return p
}

func (s *ResourceContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceContext) KW_RESOURCE() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_RESOURCE, 0)
}

func (s *ResourceContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *ResourceContext) AllSdMetadata() []ISdMetadataContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISdMetadataContext); ok {
			len++
		}
	}

	tst := make([]ISdMetadataContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISdMetadataContext); ok {
			tst[i] = t.(ISdMetadataContext)
			i++
		}
	}

	return tst
}

func (s *ResourceContext) SdMetadata(i int) ISdMetadataContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISdMetadataContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISdMetadataContext)
}

func (s *ResourceContext) AllLrRule() []ILrRuleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILrRuleContext); ok {
			len++
		}
	}

	tst := make([]ILrRuleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILrRuleContext); ok {
			tst[i] = t.(ILrRuleContext)
			i++
		}
	}

	return tst
}

func (s *ResourceContext) LrRule(i int) ILrRuleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILrRuleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILrRuleContext)
}

func (s *ResourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitResource(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Resource() (localctx IResourceContext) {
	localctx = NewResourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, FSHParserRULE_resource)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(252)
		p.Match(FSHParserKW_RESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(253)
		p.Name()
	}
	p.SetState(257)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&122880) != 0 {
		{
			p.SetState(254)
			p.SdMetadata()
		}

		p.SetState(259)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(263)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FSHParserSTAR {
		{
			p.SetState(260)
			p.LrRule()
		}

		p.SetState(265)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISdMetadataContext is an interface to support dynamic dispatch.
type ISdMetadataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Parent() IParentContext
	Id() IIdContext
	Title() ITitleContext
	Description() IDescriptionContext

	// IsSdMetadataContext differentiates from other interfaces.
	IsSdMetadataContext()
}

type SdMetadataContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySdMetadataContext() *SdMetadataContext {
	var p = new(SdMetadataContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_sdMetadata
	return p
}

func InitEmptySdMetadataContext(p *SdMetadataContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_sdMetadata
}

func (*SdMetadataContext) IsSdMetadataContext() {}

func NewSdMetadataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SdMetadataContext {
	var p = new(SdMetadataContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_sdMetadata

	return p
}

func (s *SdMetadataContext) GetParser() antlr.Parser { return s.parser }

func (s *SdMetadataContext) Parent() IParentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParentContext)
}

func (s *SdMetadataContext) Id() IIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *SdMetadataContext) Title() ITitleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITitleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITitleContext)
}

func (s *SdMetadataContext) Description() IDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptionContext)
}

func (s *SdMetadataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SdMetadataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SdMetadataContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitSdMetadata(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) SdMetadata() (localctx ISdMetadataContext) {
	localctx = NewSdMetadataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, FSHParserRULE_sdMetadata)
	p.SetState(270)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FSHParserKW_PARENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(266)
			p.Parent()
		}

	case FSHParserKW_ID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(267)
			p.Id()
		}

	case FSHParserKW_TITLE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(268)
			p.Title()
		}

	case FSHParserKW_DESCRIPTION:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(269)
			p.Description()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISdRuleContext is an interface to support dynamic dispatch.
type ISdRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CardRule() ICardRuleContext
	FlagRule() IFlagRuleContext
	ValueSetRule() IValueSetRuleContext
	FixedValueRule() IFixedValueRuleContext
	ContainsRule() IContainsRuleContext
	OnlyRule() IOnlyRuleContext
	ObeysRule() IObeysRuleContext
	CaretValueRule() ICaretValueRuleContext
	InsertRule() IInsertRuleContext
	PathRule() IPathRuleContext

	// IsSdRuleContext differentiates from other interfaces.
	IsSdRuleContext()
}

type SdRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySdRuleContext() *SdRuleContext {
	var p = new(SdRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_sdRule
	return p
}

func InitEmptySdRuleContext(p *SdRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_sdRule
}

func (*SdRuleContext) IsSdRuleContext() {}

func NewSdRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SdRuleContext {
	var p = new(SdRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_sdRule

	return p
}

func (s *SdRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *SdRuleContext) CardRule() ICardRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICardRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICardRuleContext)
}

func (s *SdRuleContext) FlagRule() IFlagRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlagRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlagRuleContext)
}

func (s *SdRuleContext) ValueSetRule() IValueSetRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueSetRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueSetRuleContext)
}

func (s *SdRuleContext) FixedValueRule() IFixedValueRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFixedValueRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFixedValueRuleContext)
}

func (s *SdRuleContext) ContainsRule() IContainsRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContainsRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContainsRuleContext)
}

func (s *SdRuleContext) OnlyRule() IOnlyRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOnlyRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOnlyRuleContext)
}

func (s *SdRuleContext) ObeysRule() IObeysRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObeysRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObeysRuleContext)
}

func (s *SdRuleContext) CaretValueRule() ICaretValueRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaretValueRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaretValueRuleContext)
}

func (s *SdRuleContext) InsertRule() IInsertRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertRuleContext)
}

func (s *SdRuleContext) PathRule() IPathRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathRuleContext)
}

func (s *SdRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SdRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SdRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitSdRule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) SdRule() (localctx ISdRuleContext) {
	localctx = NewSdRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, FSHParserRULE_sdRule)
	p.SetState(282)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(272)
			p.CardRule()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(273)
			p.FlagRule()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(274)
			p.ValueSetRule()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(275)
			p.FixedValueRule()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(276)
			p.ContainsRule()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(277)
			p.OnlyRule()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(278)
			p.ObeysRule()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(279)
			p.CaretValueRule()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(280)
			p.InsertRule()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(281)
			p.PathRule()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILrRuleContext is an interface to support dynamic dispatch.
type ILrRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SdRule() ISdRuleContext
	AddElementRule() IAddElementRuleContext
	AddCRElementRule() IAddCRElementRuleContext

	// IsLrRuleContext differentiates from other interfaces.
	IsLrRuleContext()
}

type LrRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLrRuleContext() *LrRuleContext {
	var p = new(LrRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_lrRule
	return p
}

func InitEmptyLrRuleContext(p *LrRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_lrRule
}

func (*LrRuleContext) IsLrRuleContext() {}

func NewLrRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LrRuleContext {
	var p = new(LrRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_lrRule

	return p
}

func (s *LrRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *LrRuleContext) SdRule() ISdRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISdRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISdRuleContext)
}

func (s *LrRuleContext) AddElementRule() IAddElementRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddElementRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddElementRuleContext)
}

func (s *LrRuleContext) AddCRElementRule() IAddCRElementRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddCRElementRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddCRElementRuleContext)
}

func (s *LrRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LrRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LrRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitLrRule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) LrRule() (localctx ILrRuleContext) {
	localctx = NewLrRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, FSHParserRULE_lrRule)
	p.SetState(287)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(284)
			p.SdRule()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(285)
			p.AddElementRule()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(286)
			p.AddCRElementRule()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInstanceContext is an interface to support dynamic dispatch.
type IInstanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_INSTANCE() antlr.TerminalNode
	Name() INameContext
	AllInstanceMetadata() []IInstanceMetadataContext
	InstanceMetadata(i int) IInstanceMetadataContext
	AllInstanceRule() []IInstanceRuleContext
	InstanceRule(i int) IInstanceRuleContext

	// IsInstanceContext differentiates from other interfaces.
	IsInstanceContext()
}

type InstanceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstanceContext() *InstanceContext {
	var p = new(InstanceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_instance
	return p
}

func InitEmptyInstanceContext(p *InstanceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_instance
}

func (*InstanceContext) IsInstanceContext() {}

func NewInstanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstanceContext {
	var p = new(InstanceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_instance

	return p
}

func (s *InstanceContext) GetParser() antlr.Parser { return s.parser }

func (s *InstanceContext) KW_INSTANCE() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_INSTANCE, 0)
}

func (s *InstanceContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *InstanceContext) AllInstanceMetadata() []IInstanceMetadataContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInstanceMetadataContext); ok {
			len++
		}
	}

	tst := make([]IInstanceMetadataContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInstanceMetadataContext); ok {
			tst[i] = t.(IInstanceMetadataContext)
			i++
		}
	}

	return tst
}

func (s *InstanceContext) InstanceMetadata(i int) IInstanceMetadataContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstanceMetadataContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstanceMetadataContext)
}

func (s *InstanceContext) AllInstanceRule() []IInstanceRuleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInstanceRuleContext); ok {
			len++
		}
	}

	tst := make([]IInstanceRuleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInstanceRuleContext); ok {
			tst[i] = t.(IInstanceRuleContext)
			i++
		}
	}

	return tst
}

func (s *InstanceContext) InstanceRule(i int) IInstanceRuleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstanceRuleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstanceRuleContext)
}

func (s *InstanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstanceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitInstance(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Instance() (localctx IInstanceContext) {
	localctx = NewInstanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, FSHParserRULE_instance)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(289)
		p.Match(FSHParserKW_INSTANCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(290)
		p.Name()
	}
	p.SetState(294)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1146912) != 0 {
		{
			p.SetState(291)
			p.InstanceMetadata()
		}

		p.SetState(296)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(300)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FSHParserSTAR {
		{
			p.SetState(297)
			p.InstanceRule()
		}

		p.SetState(302)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInstanceMetadataContext is an interface to support dynamic dispatch.
type IInstanceMetadataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InstanceOf() IInstanceOfContext
	Title() ITitleContext
	Description() IDescriptionContext
	Usage() IUsageContext

	// IsInstanceMetadataContext differentiates from other interfaces.
	IsInstanceMetadataContext()
}

type InstanceMetadataContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstanceMetadataContext() *InstanceMetadataContext {
	var p = new(InstanceMetadataContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_instanceMetadata
	return p
}

func InitEmptyInstanceMetadataContext(p *InstanceMetadataContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_instanceMetadata
}

func (*InstanceMetadataContext) IsInstanceMetadataContext() {}

func NewInstanceMetadataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstanceMetadataContext {
	var p = new(InstanceMetadataContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_instanceMetadata

	return p
}

func (s *InstanceMetadataContext) GetParser() antlr.Parser { return s.parser }

func (s *InstanceMetadataContext) InstanceOf() IInstanceOfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstanceOfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstanceOfContext)
}

func (s *InstanceMetadataContext) Title() ITitleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITitleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITitleContext)
}

func (s *InstanceMetadataContext) Description() IDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptionContext)
}

func (s *InstanceMetadataContext) Usage() IUsageContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsageContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsageContext)
}

func (s *InstanceMetadataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstanceMetadataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstanceMetadataContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitInstanceMetadata(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) InstanceMetadata() (localctx IInstanceMetadataContext) {
	localctx = NewInstanceMetadataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, FSHParserRULE_instanceMetadata)
	p.SetState(307)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FSHParserKW_INSTANCEOF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(303)
			p.InstanceOf()
		}

	case FSHParserKW_TITLE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(304)
			p.Title()
		}

	case FSHParserKW_DESCRIPTION:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(305)
			p.Description()
		}

	case FSHParserKW_USAGE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(306)
			p.Usage()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInstanceRuleContext is an interface to support dynamic dispatch.
type IInstanceRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FixedValueRule() IFixedValueRuleContext
	InsertRule() IInsertRuleContext
	PathRule() IPathRuleContext

	// IsInstanceRuleContext differentiates from other interfaces.
	IsInstanceRuleContext()
}

type InstanceRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstanceRuleContext() *InstanceRuleContext {
	var p = new(InstanceRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_instanceRule
	return p
}

func InitEmptyInstanceRuleContext(p *InstanceRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_instanceRule
}

func (*InstanceRuleContext) IsInstanceRuleContext() {}

func NewInstanceRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstanceRuleContext {
	var p = new(InstanceRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_instanceRule

	return p
}

func (s *InstanceRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *InstanceRuleContext) FixedValueRule() IFixedValueRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFixedValueRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFixedValueRuleContext)
}

func (s *InstanceRuleContext) InsertRule() IInsertRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertRuleContext)
}

func (s *InstanceRuleContext) PathRule() IPathRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathRuleContext)
}

func (s *InstanceRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstanceRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstanceRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitInstanceRule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) InstanceRule() (localctx IInstanceRuleContext) {
	localctx = NewInstanceRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, FSHParserRULE_instanceRule)
	p.SetState(312)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(309)
			p.FixedValueRule()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(310)
			p.InsertRule()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(311)
			p.PathRule()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInvariantContext is an interface to support dynamic dispatch.
type IInvariantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_INVARIANT() antlr.TerminalNode
	Name() INameContext
	AllInvariantMetadata() []IInvariantMetadataContext
	InvariantMetadata(i int) IInvariantMetadataContext
	AllInvariantRule() []IInvariantRuleContext
	InvariantRule(i int) IInvariantRuleContext

	// IsInvariantContext differentiates from other interfaces.
	IsInvariantContext()
}

type InvariantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInvariantContext() *InvariantContext {
	var p = new(InvariantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_invariant
	return p
}

func InitEmptyInvariantContext(p *InvariantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_invariant
}

func (*InvariantContext) IsInvariantContext() {}

func NewInvariantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InvariantContext {
	var p = new(InvariantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_invariant

	return p
}

func (s *InvariantContext) GetParser() antlr.Parser { return s.parser }

func (s *InvariantContext) KW_INVARIANT() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_INVARIANT, 0)
}

func (s *InvariantContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *InvariantContext) AllInvariantMetadata() []IInvariantMetadataContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInvariantMetadataContext); ok {
			len++
		}
	}

	tst := make([]IInvariantMetadataContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInvariantMetadataContext); ok {
			tst[i] = t.(IInvariantMetadataContext)
			i++
		}
	}

	return tst
}

func (s *InvariantContext) InvariantMetadata(i int) IInvariantMetadataContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInvariantMetadataContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInvariantMetadataContext)
}

func (s *InvariantContext) AllInvariantRule() []IInvariantRuleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInvariantRuleContext); ok {
			len++
		}
	}

	tst := make([]IInvariantRuleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInvariantRuleContext); ok {
			tst[i] = t.(IInvariantRuleContext)
			i++
		}
	}

	return tst
}

func (s *InvariantContext) InvariantRule(i int) IInvariantRuleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInvariantRuleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInvariantRuleContext)
}

func (s *InvariantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InvariantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InvariantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitInvariant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Invariant() (localctx IInvariantContext) {
	localctx = NewInvariantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, FSHParserRULE_invariant)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(314)
		p.Match(FSHParserKW_INVARIANT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(315)
		p.Name()
	}
	p.SetState(319)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&983040) != 0 {
		{
			p.SetState(316)
			p.InvariantMetadata()
		}

		p.SetState(321)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(325)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FSHParserSTAR {
		{
			p.SetState(322)
			p.InvariantRule()
		}

		p.SetState(327)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInvariantMetadataContext is an interface to support dynamic dispatch.
type IInvariantMetadataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Description() IDescriptionContext
	Expression() IExpressionContext
	Xpath() IXpathContext
	Severity() ISeverityContext

	// IsInvariantMetadataContext differentiates from other interfaces.
	IsInvariantMetadataContext()
}

type InvariantMetadataContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInvariantMetadataContext() *InvariantMetadataContext {
	var p = new(InvariantMetadataContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_invariantMetadata
	return p
}

func InitEmptyInvariantMetadataContext(p *InvariantMetadataContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_invariantMetadata
}

func (*InvariantMetadataContext) IsInvariantMetadataContext() {}

func NewInvariantMetadataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InvariantMetadataContext {
	var p = new(InvariantMetadataContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_invariantMetadata

	return p
}

func (s *InvariantMetadataContext) GetParser() antlr.Parser { return s.parser }

func (s *InvariantMetadataContext) Description() IDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptionContext)
}

func (s *InvariantMetadataContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InvariantMetadataContext) Xpath() IXpathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXpathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXpathContext)
}

func (s *InvariantMetadataContext) Severity() ISeverityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISeverityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISeverityContext)
}

func (s *InvariantMetadataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InvariantMetadataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InvariantMetadataContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitInvariantMetadata(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) InvariantMetadata() (localctx IInvariantMetadataContext) {
	localctx = NewInvariantMetadataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, FSHParserRULE_invariantMetadata)
	p.SetState(332)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FSHParserKW_DESCRIPTION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(328)
			p.Description()
		}

	case FSHParserKW_EXPRESSION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(329)
			p.Expression()
		}

	case FSHParserKW_XPATH:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(330)
			p.Xpath()
		}

	case FSHParserKW_SEVERITY:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(331)
			p.Severity()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInvariantRuleContext is an interface to support dynamic dispatch.
type IInvariantRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FixedValueRule() IFixedValueRuleContext
	InsertRule() IInsertRuleContext
	PathRule() IPathRuleContext

	// IsInvariantRuleContext differentiates from other interfaces.
	IsInvariantRuleContext()
}

type InvariantRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInvariantRuleContext() *InvariantRuleContext {
	var p = new(InvariantRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_invariantRule
	return p
}

func InitEmptyInvariantRuleContext(p *InvariantRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_invariantRule
}

func (*InvariantRuleContext) IsInvariantRuleContext() {}

func NewInvariantRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InvariantRuleContext {
	var p = new(InvariantRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_invariantRule

	return p
}

func (s *InvariantRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *InvariantRuleContext) FixedValueRule() IFixedValueRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFixedValueRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFixedValueRuleContext)
}

func (s *InvariantRuleContext) InsertRule() IInsertRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertRuleContext)
}

func (s *InvariantRuleContext) PathRule() IPathRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathRuleContext)
}

func (s *InvariantRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InvariantRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InvariantRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitInvariantRule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) InvariantRule() (localctx IInvariantRuleContext) {
	localctx = NewInvariantRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, FSHParserRULE_invariantRule)
	p.SetState(337)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(334)
			p.FixedValueRule()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(335)
			p.InsertRule()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(336)
			p.PathRule()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueSetContext is an interface to support dynamic dispatch.
type IValueSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_VALUESET() antlr.TerminalNode
	Name() INameContext
	AllVsMetadata() []IVsMetadataContext
	VsMetadata(i int) IVsMetadataContext
	AllVsRule() []IVsRuleContext
	VsRule(i int) IVsRuleContext

	// IsValueSetContext differentiates from other interfaces.
	IsValueSetContext()
}

type ValueSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueSetContext() *ValueSetContext {
	var p = new(ValueSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_valueSet
	return p
}

func InitEmptyValueSetContext(p *ValueSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_valueSet
}

func (*ValueSetContext) IsValueSetContext() {}

func NewValueSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueSetContext {
	var p = new(ValueSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_valueSet

	return p
}

func (s *ValueSetContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueSetContext) KW_VALUESET() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_VALUESET, 0)
}

func (s *ValueSetContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *ValueSetContext) AllVsMetadata() []IVsMetadataContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVsMetadataContext); ok {
			len++
		}
	}

	tst := make([]IVsMetadataContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVsMetadataContext); ok {
			tst[i] = t.(IVsMetadataContext)
			i++
		}
	}

	return tst
}

func (s *ValueSetContext) VsMetadata(i int) IVsMetadataContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVsMetadataContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVsMetadataContext)
}

func (s *ValueSetContext) AllVsRule() []IVsRuleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVsRuleContext); ok {
			len++
		}
	}

	tst := make([]IVsRuleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVsRuleContext); ok {
			tst[i] = t.(IVsRuleContext)
			i++
		}
	}

	return tst
}

func (s *ValueSetContext) VsRule(i int) IVsRuleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVsRuleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVsRuleContext)
}

func (s *ValueSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitValueSet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) ValueSet() (localctx IValueSetContext) {
	localctx = NewValueSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, FSHParserRULE_valueSet)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(339)
		p.Match(FSHParserKW_VALUESET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(340)
		p.Name()
	}
	p.SetState(344)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&114688) != 0 {
		{
			p.SetState(341)
			p.VsMetadata()
		}

		p.SetState(346)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(350)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FSHParserSTAR {
		{
			p.SetState(347)
			p.VsRule()
		}

		p.SetState(352)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVsMetadataContext is an interface to support dynamic dispatch.
type IVsMetadataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id() IIdContext
	Title() ITitleContext
	Description() IDescriptionContext

	// IsVsMetadataContext differentiates from other interfaces.
	IsVsMetadataContext()
}

type VsMetadataContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVsMetadataContext() *VsMetadataContext {
	var p = new(VsMetadataContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_vsMetadata
	return p
}

func InitEmptyVsMetadataContext(p *VsMetadataContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_vsMetadata
}

func (*VsMetadataContext) IsVsMetadataContext() {}

func NewVsMetadataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VsMetadataContext {
	var p = new(VsMetadataContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_vsMetadata

	return p
}

func (s *VsMetadataContext) GetParser() antlr.Parser { return s.parser }

func (s *VsMetadataContext) Id() IIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *VsMetadataContext) Title() ITitleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITitleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITitleContext)
}

func (s *VsMetadataContext) Description() IDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptionContext)
}

func (s *VsMetadataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsMetadataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VsMetadataContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitVsMetadata(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) VsMetadata() (localctx IVsMetadataContext) {
	localctx = NewVsMetadataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, FSHParserRULE_vsMetadata)
	p.SetState(356)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FSHParserKW_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(353)
			p.Id()
		}

	case FSHParserKW_TITLE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(354)
			p.Title()
		}

	case FSHParserKW_DESCRIPTION:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(355)
			p.Description()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVsRuleContext is an interface to support dynamic dispatch.
type IVsRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VsComponent() IVsComponentContext
	CaretValueRule() ICaretValueRuleContext
	CodeCaretValueRule() ICodeCaretValueRuleContext
	InsertRule() IInsertRuleContext
	CodeInsertRule() ICodeInsertRuleContext

	// IsVsRuleContext differentiates from other interfaces.
	IsVsRuleContext()
}

type VsRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVsRuleContext() *VsRuleContext {
	var p = new(VsRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_vsRule
	return p
}

func InitEmptyVsRuleContext(p *VsRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_vsRule
}

func (*VsRuleContext) IsVsRuleContext() {}

func NewVsRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VsRuleContext {
	var p = new(VsRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_vsRule

	return p
}

func (s *VsRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *VsRuleContext) VsComponent() IVsComponentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVsComponentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVsComponentContext)
}

func (s *VsRuleContext) CaretValueRule() ICaretValueRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaretValueRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaretValueRuleContext)
}

func (s *VsRuleContext) CodeCaretValueRule() ICodeCaretValueRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeCaretValueRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeCaretValueRuleContext)
}

func (s *VsRuleContext) InsertRule() IInsertRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertRuleContext)
}

func (s *VsRuleContext) CodeInsertRule() ICodeInsertRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeInsertRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeInsertRuleContext)
}

func (s *VsRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VsRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitVsRule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) VsRule() (localctx IVsRuleContext) {
	localctx = NewVsRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, FSHParserRULE_vsRule)
	p.SetState(363)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(358)
			p.VsComponent()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(359)
			p.CaretValueRule()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(360)
			p.CodeCaretValueRule()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(361)
			p.InsertRule()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(362)
			p.CodeInsertRule()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICodeSystemContext is an interface to support dynamic dispatch.
type ICodeSystemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_CODESYSTEM() antlr.TerminalNode
	Name() INameContext
	AllCsMetadata() []ICsMetadataContext
	CsMetadata(i int) ICsMetadataContext
	AllCsRule() []ICsRuleContext
	CsRule(i int) ICsRuleContext

	// IsCodeSystemContext differentiates from other interfaces.
	IsCodeSystemContext()
}

type CodeSystemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodeSystemContext() *CodeSystemContext {
	var p = new(CodeSystemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_codeSystem
	return p
}

func InitEmptyCodeSystemContext(p *CodeSystemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_codeSystem
}

func (*CodeSystemContext) IsCodeSystemContext() {}

func NewCodeSystemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodeSystemContext {
	var p = new(CodeSystemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_codeSystem

	return p
}

func (s *CodeSystemContext) GetParser() antlr.Parser { return s.parser }

func (s *CodeSystemContext) KW_CODESYSTEM() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_CODESYSTEM, 0)
}

func (s *CodeSystemContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *CodeSystemContext) AllCsMetadata() []ICsMetadataContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICsMetadataContext); ok {
			len++
		}
	}

	tst := make([]ICsMetadataContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICsMetadataContext); ok {
			tst[i] = t.(ICsMetadataContext)
			i++
		}
	}

	return tst
}

func (s *CodeSystemContext) CsMetadata(i int) ICsMetadataContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICsMetadataContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICsMetadataContext)
}

func (s *CodeSystemContext) AllCsRule() []ICsRuleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICsRuleContext); ok {
			len++
		}
	}

	tst := make([]ICsRuleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICsRuleContext); ok {
			tst[i] = t.(ICsRuleContext)
			i++
		}
	}

	return tst
}

func (s *CodeSystemContext) CsRule(i int) ICsRuleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICsRuleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICsRuleContext)
}

func (s *CodeSystemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeSystemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodeSystemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitCodeSystem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) CodeSystem() (localctx ICodeSystemContext) {
	localctx = NewCodeSystemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, FSHParserRULE_codeSystem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(365)
		p.Match(FSHParserKW_CODESYSTEM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(366)
		p.Name()
	}
	p.SetState(370)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&114688) != 0 {
		{
			p.SetState(367)
			p.CsMetadata()
		}

		p.SetState(372)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(376)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FSHParserSTAR {
		{
			p.SetState(373)
			p.CsRule()
		}

		p.SetState(378)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICsMetadataContext is an interface to support dynamic dispatch.
type ICsMetadataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id() IIdContext
	Title() ITitleContext
	Description() IDescriptionContext

	// IsCsMetadataContext differentiates from other interfaces.
	IsCsMetadataContext()
}

type CsMetadataContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCsMetadataContext() *CsMetadataContext {
	var p = new(CsMetadataContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_csMetadata
	return p
}

func InitEmptyCsMetadataContext(p *CsMetadataContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_csMetadata
}

func (*CsMetadataContext) IsCsMetadataContext() {}

func NewCsMetadataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CsMetadataContext {
	var p = new(CsMetadataContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_csMetadata

	return p
}

func (s *CsMetadataContext) GetParser() antlr.Parser { return s.parser }

func (s *CsMetadataContext) Id() IIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *CsMetadataContext) Title() ITitleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITitleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITitleContext)
}

func (s *CsMetadataContext) Description() IDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptionContext)
}

func (s *CsMetadataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CsMetadataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CsMetadataContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitCsMetadata(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) CsMetadata() (localctx ICsMetadataContext) {
	localctx = NewCsMetadataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, FSHParserRULE_csMetadata)
	p.SetState(382)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FSHParserKW_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(379)
			p.Id()
		}

	case FSHParserKW_TITLE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(380)
			p.Title()
		}

	case FSHParserKW_DESCRIPTION:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(381)
			p.Description()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICsRuleContext is an interface to support dynamic dispatch.
type ICsRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Concept() IConceptContext
	CodeCaretValueRule() ICodeCaretValueRuleContext
	CodeInsertRule() ICodeInsertRuleContext

	// IsCsRuleContext differentiates from other interfaces.
	IsCsRuleContext()
}

type CsRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCsRuleContext() *CsRuleContext {
	var p = new(CsRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_csRule
	return p
}

func InitEmptyCsRuleContext(p *CsRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_csRule
}

func (*CsRuleContext) IsCsRuleContext() {}

func NewCsRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CsRuleContext {
	var p = new(CsRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_csRule

	return p
}

func (s *CsRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *CsRuleContext) Concept() IConceptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConceptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConceptContext)
}

func (s *CsRuleContext) CodeCaretValueRule() ICodeCaretValueRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeCaretValueRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeCaretValueRuleContext)
}

func (s *CsRuleContext) CodeInsertRule() ICodeInsertRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeInsertRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeInsertRuleContext)
}

func (s *CsRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CsRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CsRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitCsRule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) CsRule() (localctx ICsRuleContext) {
	localctx = NewCsRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, FSHParserRULE_csRule)
	p.SetState(387)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(384)
			p.Concept()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(385)
			p.CodeCaretValueRule()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(386)
			p.CodeInsertRule()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRuleSetContext is an interface to support dynamic dispatch.
type IRuleSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_RULESET() antlr.TerminalNode
	RULESET_REFERENCE() antlr.TerminalNode
	AllRuleSetRule() []IRuleSetRuleContext
	RuleSetRule(i int) IRuleSetRuleContext

	// IsRuleSetContext differentiates from other interfaces.
	IsRuleSetContext()
}

type RuleSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleSetContext() *RuleSetContext {
	var p = new(RuleSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_ruleSet
	return p
}

func InitEmptyRuleSetContext(p *RuleSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_ruleSet
}

func (*RuleSetContext) IsRuleSetContext() {}

func NewRuleSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSetContext {
	var p = new(RuleSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_ruleSet

	return p
}

func (s *RuleSetContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleSetContext) KW_RULESET() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_RULESET, 0)
}

func (s *RuleSetContext) RULESET_REFERENCE() antlr.TerminalNode {
	return s.GetToken(FSHParserRULESET_REFERENCE, 0)
}

func (s *RuleSetContext) AllRuleSetRule() []IRuleSetRuleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRuleSetRuleContext); ok {
			len++
		}
	}

	tst := make([]IRuleSetRuleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRuleSetRuleContext); ok {
			tst[i] = t.(IRuleSetRuleContext)
			i++
		}
	}

	return tst
}

func (s *RuleSetContext) RuleSetRule(i int) IRuleSetRuleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSetRuleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSetRuleContext)
}

func (s *RuleSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitRuleSet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) RuleSet() (localctx IRuleSetContext) {
	localctx = NewRuleSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, FSHParserRULE_ruleSet)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(389)
		p.Match(FSHParserKW_RULESET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(390)
		p.Match(FSHParserRULESET_REFERENCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(392)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == FSHParserSTAR {
		{
			p.SetState(391)
			p.RuleSetRule()
		}

		p.SetState(394)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRuleSetRuleContext is an interface to support dynamic dispatch.
type IRuleSetRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SdRule() ISdRuleContext
	AddElementRule() IAddElementRuleContext
	AddCRElementRule() IAddCRElementRuleContext
	Concept() IConceptContext
	CodeCaretValueRule() ICodeCaretValueRuleContext
	CodeInsertRule() ICodeInsertRuleContext
	VsComponent() IVsComponentContext
	MappingRule() IMappingRuleContext

	// IsRuleSetRuleContext differentiates from other interfaces.
	IsRuleSetRuleContext()
}

type RuleSetRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleSetRuleContext() *RuleSetRuleContext {
	var p = new(RuleSetRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_ruleSetRule
	return p
}

func InitEmptyRuleSetRuleContext(p *RuleSetRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_ruleSetRule
}

func (*RuleSetRuleContext) IsRuleSetRuleContext() {}

func NewRuleSetRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSetRuleContext {
	var p = new(RuleSetRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_ruleSetRule

	return p
}

func (s *RuleSetRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleSetRuleContext) SdRule() ISdRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISdRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISdRuleContext)
}

func (s *RuleSetRuleContext) AddElementRule() IAddElementRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddElementRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddElementRuleContext)
}

func (s *RuleSetRuleContext) AddCRElementRule() IAddCRElementRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddCRElementRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddCRElementRuleContext)
}

func (s *RuleSetRuleContext) Concept() IConceptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConceptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConceptContext)
}

func (s *RuleSetRuleContext) CodeCaretValueRule() ICodeCaretValueRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeCaretValueRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeCaretValueRuleContext)
}

func (s *RuleSetRuleContext) CodeInsertRule() ICodeInsertRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeInsertRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeInsertRuleContext)
}

func (s *RuleSetRuleContext) VsComponent() IVsComponentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVsComponentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVsComponentContext)
}

func (s *RuleSetRuleContext) MappingRule() IMappingRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMappingRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMappingRuleContext)
}

func (s *RuleSetRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSetRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSetRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitRuleSetRule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) RuleSetRule() (localctx IRuleSetRuleContext) {
	localctx = NewRuleSetRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, FSHParserRULE_ruleSetRule)
	p.SetState(404)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(396)
			p.SdRule()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(397)
			p.AddElementRule()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(398)
			p.AddCRElementRule()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(399)
			p.Concept()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(400)
			p.CodeCaretValueRule()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(401)
			p.CodeInsertRule()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(402)
			p.VsComponent()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(403)
			p.MappingRule()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParamRuleSetContext is an interface to support dynamic dispatch.
type IParamRuleSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_RULESET() antlr.TerminalNode
	ParamRuleSetRef() IParamRuleSetRefContext
	ParamRuleSetContent() IParamRuleSetContentContext

	// IsParamRuleSetContext differentiates from other interfaces.
	IsParamRuleSetContext()
}

type ParamRuleSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamRuleSetContext() *ParamRuleSetContext {
	var p = new(ParamRuleSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_paramRuleSet
	return p
}

func InitEmptyParamRuleSetContext(p *ParamRuleSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_paramRuleSet
}

func (*ParamRuleSetContext) IsParamRuleSetContext() {}

func NewParamRuleSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamRuleSetContext {
	var p = new(ParamRuleSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_paramRuleSet

	return p
}

func (s *ParamRuleSetContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamRuleSetContext) KW_RULESET() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_RULESET, 0)
}

func (s *ParamRuleSetContext) ParamRuleSetRef() IParamRuleSetRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamRuleSetRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamRuleSetRefContext)
}

func (s *ParamRuleSetContext) ParamRuleSetContent() IParamRuleSetContentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamRuleSetContentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamRuleSetContentContext)
}

func (s *ParamRuleSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamRuleSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamRuleSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitParamRuleSet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) ParamRuleSet() (localctx IParamRuleSetContext) {
	localctx = NewParamRuleSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, FSHParserRULE_paramRuleSet)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(406)
		p.Match(FSHParserKW_RULESET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(407)
		p.ParamRuleSetRef()
	}
	{
		p.SetState(408)
		p.ParamRuleSetContent()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParamRuleSetRefContext is an interface to support dynamic dispatch.
type IParamRuleSetRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARAM_RULESET_REFERENCE() antlr.TerminalNode
	LastParameter() ILastParameterContext
	AllParameter() []IParameterContext
	Parameter(i int) IParameterContext

	// IsParamRuleSetRefContext differentiates from other interfaces.
	IsParamRuleSetRefContext()
}

type ParamRuleSetRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamRuleSetRefContext() *ParamRuleSetRefContext {
	var p = new(ParamRuleSetRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_paramRuleSetRef
	return p
}

func InitEmptyParamRuleSetRefContext(p *ParamRuleSetRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_paramRuleSetRef
}

func (*ParamRuleSetRefContext) IsParamRuleSetRefContext() {}

func NewParamRuleSetRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamRuleSetRefContext {
	var p = new(ParamRuleSetRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_paramRuleSetRef

	return p
}

func (s *ParamRuleSetRefContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamRuleSetRefContext) PARAM_RULESET_REFERENCE() antlr.TerminalNode {
	return s.GetToken(FSHParserPARAM_RULESET_REFERENCE, 0)
}

func (s *ParamRuleSetRefContext) LastParameter() ILastParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILastParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILastParameterContext)
}

func (s *ParamRuleSetRefContext) AllParameter() []IParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParameterContext); ok {
			len++
		}
	}

	tst := make([]IParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParameterContext); ok {
			tst[i] = t.(IParameterContext)
			i++
		}
	}

	return tst
}

func (s *ParamRuleSetRefContext) Parameter(i int) IParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *ParamRuleSetRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamRuleSetRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamRuleSetRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitParamRuleSetRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) ParamRuleSetRef() (localctx IParamRuleSetRefContext) {
	localctx = NewParamRuleSetRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, FSHParserRULE_paramRuleSetRef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(410)
		p.Match(FSHParserPARAM_RULESET_REFERENCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(414)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FSHParserBRACKETED_PARAM || _la == FSHParserPLAIN_PARAM {
		{
			p.SetState(411)
			p.Parameter()
		}

		p.SetState(416)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(417)
		p.LastParameter()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterContext is an interface to support dynamic dispatch.
type IParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BRACKETED_PARAM() antlr.TerminalNode
	PLAIN_PARAM() antlr.TerminalNode

	// IsParameterContext differentiates from other interfaces.
	IsParameterContext()
}

type ParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterContext() *ParameterContext {
	var p = new(ParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_parameter
	return p
}

func InitEmptyParameterContext(p *ParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_parameter
}

func (*ParameterContext) IsParameterContext() {}

func NewParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterContext {
	var p = new(ParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_parameter

	return p
}

func (s *ParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterContext) BRACKETED_PARAM() antlr.TerminalNode {
	return s.GetToken(FSHParserBRACKETED_PARAM, 0)
}

func (s *ParameterContext) PLAIN_PARAM() antlr.TerminalNode {
	return s.GetToken(FSHParserPLAIN_PARAM, 0)
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Parameter() (localctx IParameterContext) {
	localctx = NewParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, FSHParserRULE_parameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(419)
		_la = p.GetTokenStream().LA(1)

		if !(_la == FSHParserBRACKETED_PARAM || _la == FSHParserPLAIN_PARAM) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILastParameterContext is an interface to support dynamic dispatch.
type ILastParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LAST_BRACKETED_PARAM() antlr.TerminalNode
	LAST_PLAIN_PARAM() antlr.TerminalNode

	// IsLastParameterContext differentiates from other interfaces.
	IsLastParameterContext()
}

type LastParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLastParameterContext() *LastParameterContext {
	var p = new(LastParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_lastParameter
	return p
}

func InitEmptyLastParameterContext(p *LastParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_lastParameter
}

func (*LastParameterContext) IsLastParameterContext() {}

func NewLastParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LastParameterContext {
	var p = new(LastParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_lastParameter

	return p
}

func (s *LastParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *LastParameterContext) LAST_BRACKETED_PARAM() antlr.TerminalNode {
	return s.GetToken(FSHParserLAST_BRACKETED_PARAM, 0)
}

func (s *LastParameterContext) LAST_PLAIN_PARAM() antlr.TerminalNode {
	return s.GetToken(FSHParserLAST_PLAIN_PARAM, 0)
}

func (s *LastParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LastParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LastParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitLastParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) LastParameter() (localctx ILastParameterContext) {
	localctx = NewLastParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, FSHParserRULE_lastParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(421)
		_la = p.GetTokenStream().LA(1)

		if !(_la == FSHParserLAST_BRACKETED_PARAM || _la == FSHParserLAST_PLAIN_PARAM) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParamRuleSetContentContext is an interface to support dynamic dispatch.
type IParamRuleSetContentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	AllKW_PROFILE() []antlr.TerminalNode
	KW_PROFILE(i int) antlr.TerminalNode
	AllKW_ALIAS() []antlr.TerminalNode
	KW_ALIAS(i int) antlr.TerminalNode
	AllKW_EXTENSION() []antlr.TerminalNode
	KW_EXTENSION(i int) antlr.TerminalNode
	AllKW_INSTANCE() []antlr.TerminalNode
	KW_INSTANCE(i int) antlr.TerminalNode
	AllKW_INVARIANT() []antlr.TerminalNode
	KW_INVARIANT(i int) antlr.TerminalNode
	AllKW_VALUESET() []antlr.TerminalNode
	KW_VALUESET(i int) antlr.TerminalNode
	AllKW_CODESYSTEM() []antlr.TerminalNode
	KW_CODESYSTEM(i int) antlr.TerminalNode
	AllKW_RULESET() []antlr.TerminalNode
	KW_RULESET(i int) antlr.TerminalNode
	AllKW_MAPPING() []antlr.TerminalNode
	KW_MAPPING(i int) antlr.TerminalNode
	AllKW_LOGICAL() []antlr.TerminalNode
	KW_LOGICAL(i int) antlr.TerminalNode
	AllKW_RESOURCE() []antlr.TerminalNode
	KW_RESOURCE(i int) antlr.TerminalNode

	// IsParamRuleSetContentContext differentiates from other interfaces.
	IsParamRuleSetContentContext()
}

type ParamRuleSetContentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamRuleSetContentContext() *ParamRuleSetContentContext {
	var p = new(ParamRuleSetContentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_paramRuleSetContent
	return p
}

func InitEmptyParamRuleSetContentContext(p *ParamRuleSetContentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_paramRuleSetContent
}

func (*ParamRuleSetContentContext) IsParamRuleSetContentContext() {}

func NewParamRuleSetContentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamRuleSetContentContext {
	var p = new(ParamRuleSetContentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_paramRuleSetContent

	return p
}

func (s *ParamRuleSetContentContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamRuleSetContentContext) STAR() antlr.TerminalNode {
	return s.GetToken(FSHParserSTAR, 0)
}

func (s *ParamRuleSetContentContext) AllKW_PROFILE() []antlr.TerminalNode {
	return s.GetTokens(FSHParserKW_PROFILE)
}

func (s *ParamRuleSetContentContext) KW_PROFILE(i int) antlr.TerminalNode {
	return s.GetToken(FSHParserKW_PROFILE, i)
}

func (s *ParamRuleSetContentContext) AllKW_ALIAS() []antlr.TerminalNode {
	return s.GetTokens(FSHParserKW_ALIAS)
}

func (s *ParamRuleSetContentContext) KW_ALIAS(i int) antlr.TerminalNode {
	return s.GetToken(FSHParserKW_ALIAS, i)
}

func (s *ParamRuleSetContentContext) AllKW_EXTENSION() []antlr.TerminalNode {
	return s.GetTokens(FSHParserKW_EXTENSION)
}

func (s *ParamRuleSetContentContext) KW_EXTENSION(i int) antlr.TerminalNode {
	return s.GetToken(FSHParserKW_EXTENSION, i)
}

func (s *ParamRuleSetContentContext) AllKW_INSTANCE() []antlr.TerminalNode {
	return s.GetTokens(FSHParserKW_INSTANCE)
}

func (s *ParamRuleSetContentContext) KW_INSTANCE(i int) antlr.TerminalNode {
	return s.GetToken(FSHParserKW_INSTANCE, i)
}

func (s *ParamRuleSetContentContext) AllKW_INVARIANT() []antlr.TerminalNode {
	return s.GetTokens(FSHParserKW_INVARIANT)
}

func (s *ParamRuleSetContentContext) KW_INVARIANT(i int) antlr.TerminalNode {
	return s.GetToken(FSHParserKW_INVARIANT, i)
}

func (s *ParamRuleSetContentContext) AllKW_VALUESET() []antlr.TerminalNode {
	return s.GetTokens(FSHParserKW_VALUESET)
}

func (s *ParamRuleSetContentContext) KW_VALUESET(i int) antlr.TerminalNode {
	return s.GetToken(FSHParserKW_VALUESET, i)
}

func (s *ParamRuleSetContentContext) AllKW_CODESYSTEM() []antlr.TerminalNode {
	return s.GetTokens(FSHParserKW_CODESYSTEM)
}

func (s *ParamRuleSetContentContext) KW_CODESYSTEM(i int) antlr.TerminalNode {
	return s.GetToken(FSHParserKW_CODESYSTEM, i)
}

func (s *ParamRuleSetContentContext) AllKW_RULESET() []antlr.TerminalNode {
	return s.GetTokens(FSHParserKW_RULESET)
}

func (s *ParamRuleSetContentContext) KW_RULESET(i int) antlr.TerminalNode {
	return s.GetToken(FSHParserKW_RULESET, i)
}

func (s *ParamRuleSetContentContext) AllKW_MAPPING() []antlr.TerminalNode {
	return s.GetTokens(FSHParserKW_MAPPING)
}

func (s *ParamRuleSetContentContext) KW_MAPPING(i int) antlr.TerminalNode {
	return s.GetToken(FSHParserKW_MAPPING, i)
}

func (s *ParamRuleSetContentContext) AllKW_LOGICAL() []antlr.TerminalNode {
	return s.GetTokens(FSHParserKW_LOGICAL)
}

func (s *ParamRuleSetContentContext) KW_LOGICAL(i int) antlr.TerminalNode {
	return s.GetToken(FSHParserKW_LOGICAL, i)
}

func (s *ParamRuleSetContentContext) AllKW_RESOURCE() []antlr.TerminalNode {
	return s.GetTokens(FSHParserKW_RESOURCE)
}

func (s *ParamRuleSetContentContext) KW_RESOURCE(i int) antlr.TerminalNode {
	return s.GetToken(FSHParserKW_RESOURCE, i)
}

func (s *ParamRuleSetContentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamRuleSetContentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamRuleSetContentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitParamRuleSetContent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) ParamRuleSetContent() (localctx IParamRuleSetContentContext) {
	localctx = NewParamRuleSetContentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, FSHParserRULE_paramRuleSetContent)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(423)
		p.Match(FSHParserSTAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(427)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-8160) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&67108863) != 0) {
		{
			p.SetState(424)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8158) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		p.SetState(429)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMappingContext is an interface to support dynamic dispatch.
type IMappingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_MAPPING() antlr.TerminalNode
	Name() INameContext
	AllMappingMetadata() []IMappingMetadataContext
	MappingMetadata(i int) IMappingMetadataContext
	AllMappingEntityRule() []IMappingEntityRuleContext
	MappingEntityRule(i int) IMappingEntityRuleContext

	// IsMappingContext differentiates from other interfaces.
	IsMappingContext()
}

type MappingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMappingContext() *MappingContext {
	var p = new(MappingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_mapping
	return p
}

func InitEmptyMappingContext(p *MappingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_mapping
}

func (*MappingContext) IsMappingContext() {}

func NewMappingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MappingContext {
	var p = new(MappingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_mapping

	return p
}

func (s *MappingContext) GetParser() antlr.Parser { return s.parser }

func (s *MappingContext) KW_MAPPING() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_MAPPING, 0)
}

func (s *MappingContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *MappingContext) AllMappingMetadata() []IMappingMetadataContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMappingMetadataContext); ok {
			len++
		}
	}

	tst := make([]IMappingMetadataContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMappingMetadataContext); ok {
			tst[i] = t.(IMappingMetadataContext)
			i++
		}
	}

	return tst
}

func (s *MappingContext) MappingMetadata(i int) IMappingMetadataContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMappingMetadataContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMappingMetadataContext)
}

func (s *MappingContext) AllMappingEntityRule() []IMappingEntityRuleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMappingEntityRuleContext); ok {
			len++
		}
	}

	tst := make([]IMappingEntityRuleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMappingEntityRuleContext); ok {
			tst[i] = t.(IMappingEntityRuleContext)
			i++
		}
	}

	return tst
}

func (s *MappingContext) MappingEntityRule(i int) IMappingEntityRuleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMappingEntityRuleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMappingEntityRuleContext)
}

func (s *MappingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MappingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MappingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitMapping(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Mapping() (localctx IMappingContext) {
	localctx = NewMappingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, FSHParserRULE_mapping)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(430)
		p.Match(FSHParserKW_MAPPING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(431)
		p.Name()
	}
	p.SetState(435)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&6406144) != 0 {
		{
			p.SetState(432)
			p.MappingMetadata()
		}

		p.SetState(437)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(441)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FSHParserSTAR {
		{
			p.SetState(438)
			p.MappingEntityRule()
		}

		p.SetState(443)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMappingMetadataContext is an interface to support dynamic dispatch.
type IMappingMetadataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id() IIdContext
	Source() ISourceContext
	Target() ITargetContext
	Description() IDescriptionContext
	Title() ITitleContext

	// IsMappingMetadataContext differentiates from other interfaces.
	IsMappingMetadataContext()
}

type MappingMetadataContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMappingMetadataContext() *MappingMetadataContext {
	var p = new(MappingMetadataContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_mappingMetadata
	return p
}

func InitEmptyMappingMetadataContext(p *MappingMetadataContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_mappingMetadata
}

func (*MappingMetadataContext) IsMappingMetadataContext() {}

func NewMappingMetadataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MappingMetadataContext {
	var p = new(MappingMetadataContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_mappingMetadata

	return p
}

func (s *MappingMetadataContext) GetParser() antlr.Parser { return s.parser }

func (s *MappingMetadataContext) Id() IIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *MappingMetadataContext) Source() ISourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceContext)
}

func (s *MappingMetadataContext) Target() ITargetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetContext)
}

func (s *MappingMetadataContext) Description() IDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptionContext)
}

func (s *MappingMetadataContext) Title() ITitleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITitleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITitleContext)
}

func (s *MappingMetadataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MappingMetadataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MappingMetadataContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitMappingMetadata(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) MappingMetadata() (localctx IMappingMetadataContext) {
	localctx = NewMappingMetadataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, FSHParserRULE_mappingMetadata)
	p.SetState(449)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FSHParserKW_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(444)
			p.Id()
		}

	case FSHParserKW_SOURCE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(445)
			p.Source()
		}

	case FSHParserKW_TARGET:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(446)
			p.Target()
		}

	case FSHParserKW_DESCRIPTION:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(447)
			p.Description()
		}

	case FSHParserKW_TITLE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(448)
			p.Title()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMappingEntityRuleContext is an interface to support dynamic dispatch.
type IMappingEntityRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MappingRule() IMappingRuleContext
	InsertRule() IInsertRuleContext
	PathRule() IPathRuleContext

	// IsMappingEntityRuleContext differentiates from other interfaces.
	IsMappingEntityRuleContext()
}

type MappingEntityRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMappingEntityRuleContext() *MappingEntityRuleContext {
	var p = new(MappingEntityRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_mappingEntityRule
	return p
}

func InitEmptyMappingEntityRuleContext(p *MappingEntityRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_mappingEntityRule
}

func (*MappingEntityRuleContext) IsMappingEntityRuleContext() {}

func NewMappingEntityRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MappingEntityRuleContext {
	var p = new(MappingEntityRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_mappingEntityRule

	return p
}

func (s *MappingEntityRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *MappingEntityRuleContext) MappingRule() IMappingRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMappingRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMappingRuleContext)
}

func (s *MappingEntityRuleContext) InsertRule() IInsertRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertRuleContext)
}

func (s *MappingEntityRuleContext) PathRule() IPathRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathRuleContext)
}

func (s *MappingEntityRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MappingEntityRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MappingEntityRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitMappingEntityRule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) MappingEntityRule() (localctx IMappingEntityRuleContext) {
	localctx = NewMappingEntityRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, FSHParserRULE_mappingEntityRule)
	p.SetState(454)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(451)
			p.MappingRule()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(452)
			p.InsertRule()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(453)
			p.PathRule()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParentContext is an interface to support dynamic dispatch.
type IParentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_PARENT() antlr.TerminalNode
	Name() INameContext

	// IsParentContext differentiates from other interfaces.
	IsParentContext()
}

type ParentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParentContext() *ParentContext {
	var p = new(ParentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_parent
	return p
}

func InitEmptyParentContext(p *ParentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_parent
}

func (*ParentContext) IsParentContext() {}

func NewParentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParentContext {
	var p = new(ParentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_parent

	return p
}

func (s *ParentContext) GetParser() antlr.Parser { return s.parser }

func (s *ParentContext) KW_PARENT() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_PARENT, 0)
}

func (s *ParentContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *ParentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitParent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Parent() (localctx IParentContext) {
	localctx = NewParentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, FSHParserRULE_parent)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(456)
		p.Match(FSHParserKW_PARENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(457)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdContext is an interface to support dynamic dispatch.
type IIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_ID() antlr.TerminalNode
	Name() INameContext

	// IsIdContext differentiates from other interfaces.
	IsIdContext()
}

type IdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdContext() *IdContext {
	var p = new(IdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_id
	return p
}

func InitEmptyIdContext(p *IdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_id
}

func (*IdContext) IsIdContext() {}

func NewIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdContext {
	var p = new(IdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_id

	return p
}

func (s *IdContext) GetParser() antlr.Parser { return s.parser }

func (s *IdContext) KW_ID() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_ID, 0)
}

func (s *IdContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *IdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Id() (localctx IIdContext) {
	localctx = NewIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, FSHParserRULE_id)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(459)
		p.Match(FSHParserKW_ID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(460)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITitleContext is an interface to support dynamic dispatch.
type ITitleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_TITLE() antlr.TerminalNode
	STRING() antlr.TerminalNode

	// IsTitleContext differentiates from other interfaces.
	IsTitleContext()
}

type TitleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTitleContext() *TitleContext {
	var p = new(TitleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_title
	return p
}

func InitEmptyTitleContext(p *TitleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_title
}

func (*TitleContext) IsTitleContext() {}

func NewTitleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TitleContext {
	var p = new(TitleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_title

	return p
}

func (s *TitleContext) GetParser() antlr.Parser { return s.parser }

func (s *TitleContext) KW_TITLE() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_TITLE, 0)
}

func (s *TitleContext) STRING() antlr.TerminalNode {
	return s.GetToken(FSHParserSTRING, 0)
}

func (s *TitleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TitleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TitleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitTitle(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Title() (localctx ITitleContext) {
	localctx = NewTitleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, FSHParserRULE_title)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(462)
		p.Match(FSHParserKW_TITLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(463)
		p.Match(FSHParserSTRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDescriptionContext is an interface to support dynamic dispatch.
type IDescriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_DESCRIPTION() antlr.TerminalNode
	STRING() antlr.TerminalNode
	MULTILINE_STRING() antlr.TerminalNode

	// IsDescriptionContext differentiates from other interfaces.
	IsDescriptionContext()
}

type DescriptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescriptionContext() *DescriptionContext {
	var p = new(DescriptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_description
	return p
}

func InitEmptyDescriptionContext(p *DescriptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_description
}

func (*DescriptionContext) IsDescriptionContext() {}

func NewDescriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescriptionContext {
	var p = new(DescriptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_description

	return p
}

func (s *DescriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DescriptionContext) KW_DESCRIPTION() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_DESCRIPTION, 0)
}

func (s *DescriptionContext) STRING() antlr.TerminalNode {
	return s.GetToken(FSHParserSTRING, 0)
}

func (s *DescriptionContext) MULTILINE_STRING() antlr.TerminalNode {
	return s.GetToken(FSHParserMULTILINE_STRING, 0)
}

func (s *DescriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescriptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitDescription(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Description() (localctx IDescriptionContext) {
	localctx = NewDescriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, FSHParserRULE_description)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(465)
		p.Match(FSHParserKW_DESCRIPTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(466)
		_la = p.GetTokenStream().LA(1)

		if !(_la == FSHParserSTRING || _la == FSHParserMULTILINE_STRING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_EXPRESSION() antlr.TerminalNode
	STRING() antlr.TerminalNode

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) KW_EXPRESSION() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_EXPRESSION, 0)
}

func (s *ExpressionContext) STRING() antlr.TerminalNode {
	return s.GetToken(FSHParserSTRING, 0)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, FSHParserRULE_expression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(468)
		p.Match(FSHParserKW_EXPRESSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(469)
		p.Match(FSHParserSTRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IXpathContext is an interface to support dynamic dispatch.
type IXpathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_XPATH() antlr.TerminalNode
	STRING() antlr.TerminalNode

	// IsXpathContext differentiates from other interfaces.
	IsXpathContext()
}

type XpathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXpathContext() *XpathContext {
	var p = new(XpathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_xpath
	return p
}

func InitEmptyXpathContext(p *XpathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_xpath
}

func (*XpathContext) IsXpathContext() {}

func NewXpathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XpathContext {
	var p = new(XpathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_xpath

	return p
}

func (s *XpathContext) GetParser() antlr.Parser { return s.parser }

func (s *XpathContext) KW_XPATH() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_XPATH, 0)
}

func (s *XpathContext) STRING() antlr.TerminalNode {
	return s.GetToken(FSHParserSTRING, 0)
}

func (s *XpathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XpathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XpathContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitXpath(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Xpath() (localctx IXpathContext) {
	localctx = NewXpathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, FSHParserRULE_xpath)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(471)
		p.Match(FSHParserKW_XPATH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(472)
		p.Match(FSHParserSTRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISeverityContext is an interface to support dynamic dispatch.
type ISeverityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_SEVERITY() antlr.TerminalNode
	CODE() antlr.TerminalNode

	// IsSeverityContext differentiates from other interfaces.
	IsSeverityContext()
}

type SeverityContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySeverityContext() *SeverityContext {
	var p = new(SeverityContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_severity
	return p
}

func InitEmptySeverityContext(p *SeverityContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_severity
}

func (*SeverityContext) IsSeverityContext() {}

func NewSeverityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SeverityContext {
	var p = new(SeverityContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_severity

	return p
}

func (s *SeverityContext) GetParser() antlr.Parser { return s.parser }

func (s *SeverityContext) KW_SEVERITY() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_SEVERITY, 0)
}

func (s *SeverityContext) CODE() antlr.TerminalNode {
	return s.GetToken(FSHParserCODE, 0)
}

func (s *SeverityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SeverityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SeverityContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitSeverity(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Severity() (localctx ISeverityContext) {
	localctx = NewSeverityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, FSHParserRULE_severity)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(474)
		p.Match(FSHParserKW_SEVERITY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(475)
		p.Match(FSHParserCODE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInstanceOfContext is an interface to support dynamic dispatch.
type IInstanceOfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_INSTANCEOF() antlr.TerminalNode
	Name() INameContext

	// IsInstanceOfContext differentiates from other interfaces.
	IsInstanceOfContext()
}

type InstanceOfContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstanceOfContext() *InstanceOfContext {
	var p = new(InstanceOfContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_instanceOf
	return p
}

func InitEmptyInstanceOfContext(p *InstanceOfContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_instanceOf
}

func (*InstanceOfContext) IsInstanceOfContext() {}

func NewInstanceOfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstanceOfContext {
	var p = new(InstanceOfContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_instanceOf

	return p
}

func (s *InstanceOfContext) GetParser() antlr.Parser { return s.parser }

func (s *InstanceOfContext) KW_INSTANCEOF() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_INSTANCEOF, 0)
}

func (s *InstanceOfContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *InstanceOfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstanceOfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstanceOfContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitInstanceOf(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) InstanceOf() (localctx IInstanceOfContext) {
	localctx = NewInstanceOfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, FSHParserRULE_instanceOf)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(477)
		p.Match(FSHParserKW_INSTANCEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(478)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUsageContext is an interface to support dynamic dispatch.
type IUsageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_USAGE() antlr.TerminalNode
	CODE() antlr.TerminalNode

	// IsUsageContext differentiates from other interfaces.
	IsUsageContext()
}

type UsageContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsageContext() *UsageContext {
	var p = new(UsageContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_usage
	return p
}

func InitEmptyUsageContext(p *UsageContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_usage
}

func (*UsageContext) IsUsageContext() {}

func NewUsageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsageContext {
	var p = new(UsageContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_usage

	return p
}

func (s *UsageContext) GetParser() antlr.Parser { return s.parser }

func (s *UsageContext) KW_USAGE() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_USAGE, 0)
}

func (s *UsageContext) CODE() antlr.TerminalNode {
	return s.GetToken(FSHParserCODE, 0)
}

func (s *UsageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsageContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitUsage(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Usage() (localctx IUsageContext) {
	localctx = NewUsageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, FSHParserRULE_usage)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(480)
		p.Match(FSHParserKW_USAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(481)
		p.Match(FSHParserCODE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISourceContext is an interface to support dynamic dispatch.
type ISourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_SOURCE() antlr.TerminalNode
	Name() INameContext

	// IsSourceContext differentiates from other interfaces.
	IsSourceContext()
}

type SourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceContext() *SourceContext {
	var p = new(SourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_source
	return p
}

func InitEmptySourceContext(p *SourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_source
}

func (*SourceContext) IsSourceContext() {}

func NewSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceContext {
	var p = new(SourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_source

	return p
}

func (s *SourceContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceContext) KW_SOURCE() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_SOURCE, 0)
}

func (s *SourceContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *SourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitSource(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Source() (localctx ISourceContext) {
	localctx = NewSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, FSHParserRULE_source)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(483)
		p.Match(FSHParserKW_SOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(484)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetContext is an interface to support dynamic dispatch.
type ITargetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_TARGET() antlr.TerminalNode
	STRING() antlr.TerminalNode

	// IsTargetContext differentiates from other interfaces.
	IsTargetContext()
}

type TargetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetContext() *TargetContext {
	var p = new(TargetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_target
	return p
}

func InitEmptyTargetContext(p *TargetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_target
}

func (*TargetContext) IsTargetContext() {}

func NewTargetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetContext {
	var p = new(TargetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_target

	return p
}

func (s *TargetContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetContext) KW_TARGET() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_TARGET, 0)
}

func (s *TargetContext) STRING() antlr.TerminalNode {
	return s.GetToken(FSHParserSTRING, 0)
}

func (s *TargetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TargetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitTarget(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Target() (localctx ITargetContext) {
	localctx = NewTargetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, FSHParserRULE_target)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(486)
		p.Match(FSHParserKW_TARGET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(487)
		p.Match(FSHParserSTRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContextContext is an interface to support dynamic dispatch.
type IContextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_CONTEXT() antlr.TerminalNode
	LastContextItem() ILastContextItemContext
	AllContextItem() []IContextItemContext
	ContextItem(i int) IContextItemContext

	// IsContextContext differentiates from other interfaces.
	IsContextContext()
}

type ContextContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContextContext() *ContextContext {
	var p = new(ContextContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_context
	return p
}

func InitEmptyContextContext(p *ContextContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_context
}

func (*ContextContext) IsContextContext() {}

func NewContextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContextContext {
	var p = new(ContextContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_context

	return p
}

func (s *ContextContext) GetParser() antlr.Parser { return s.parser }

func (s *ContextContext) KW_CONTEXT() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_CONTEXT, 0)
}

func (s *ContextContext) LastContextItem() ILastContextItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILastContextItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILastContextItemContext)
}

func (s *ContextContext) AllContextItem() []IContextItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IContextItemContext); ok {
			len++
		}
	}

	tst := make([]IContextItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IContextItemContext); ok {
			tst[i] = t.(IContextItemContext)
			i++
		}
	}

	return tst
}

func (s *ContextContext) ContextItem(i int) IContextItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContextItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContextItemContext)
}

func (s *ContextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContextContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitContext(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Context() (localctx IContextContext) {
	localctx = NewContextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, FSHParserRULE_context)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(489)
		p.Match(FSHParserKW_CONTEXT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(493)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FSHParserQUOTED_CONTEXT || _la == FSHParserUNQUOTED_CONTEXT {
		{
			p.SetState(490)
			p.ContextItem()
		}

		p.SetState(495)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(496)
		p.LastContextItem()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContextItemContext is an interface to support dynamic dispatch.
type IContextItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QUOTED_CONTEXT() antlr.TerminalNode
	UNQUOTED_CONTEXT() antlr.TerminalNode

	// IsContextItemContext differentiates from other interfaces.
	IsContextItemContext()
}

type ContextItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContextItemContext() *ContextItemContext {
	var p = new(ContextItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_contextItem
	return p
}

func InitEmptyContextItemContext(p *ContextItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_contextItem
}

func (*ContextItemContext) IsContextItemContext() {}

func NewContextItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContextItemContext {
	var p = new(ContextItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_contextItem

	return p
}

func (s *ContextItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ContextItemContext) QUOTED_CONTEXT() antlr.TerminalNode {
	return s.GetToken(FSHParserQUOTED_CONTEXT, 0)
}

func (s *ContextItemContext) UNQUOTED_CONTEXT() antlr.TerminalNode {
	return s.GetToken(FSHParserUNQUOTED_CONTEXT, 0)
}

func (s *ContextItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContextItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContextItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitContextItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) ContextItem() (localctx IContextItemContext) {
	localctx = NewContextItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, FSHParserRULE_contextItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(498)
		_la = p.GetTokenStream().LA(1)

		if !(_la == FSHParserQUOTED_CONTEXT || _la == FSHParserUNQUOTED_CONTEXT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILastContextItemContext is an interface to support dynamic dispatch.
type ILastContextItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LAST_QUOTED_CONTEXT() antlr.TerminalNode
	LAST_UNQUOTED_CONTEXT() antlr.TerminalNode

	// IsLastContextItemContext differentiates from other interfaces.
	IsLastContextItemContext()
}

type LastContextItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLastContextItemContext() *LastContextItemContext {
	var p = new(LastContextItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_lastContextItem
	return p
}

func InitEmptyLastContextItemContext(p *LastContextItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_lastContextItem
}

func (*LastContextItemContext) IsLastContextItemContext() {}

func NewLastContextItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LastContextItemContext {
	var p = new(LastContextItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_lastContextItem

	return p
}

func (s *LastContextItemContext) GetParser() antlr.Parser { return s.parser }

func (s *LastContextItemContext) LAST_QUOTED_CONTEXT() antlr.TerminalNode {
	return s.GetToken(FSHParserLAST_QUOTED_CONTEXT, 0)
}

func (s *LastContextItemContext) LAST_UNQUOTED_CONTEXT() antlr.TerminalNode {
	return s.GetToken(FSHParserLAST_UNQUOTED_CONTEXT, 0)
}

func (s *LastContextItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LastContextItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LastContextItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitLastContextItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) LastContextItem() (localctx ILastContextItemContext) {
	localctx = NewLastContextItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, FSHParserRULE_lastContextItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(500)
		_la = p.GetTokenStream().LA(1)

		if !(_la == FSHParserLAST_QUOTED_CONTEXT || _la == FSHParserLAST_UNQUOTED_CONTEXT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharacteristicsContext is an interface to support dynamic dispatch.
type ICharacteristicsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_CHARACTERISTICS() antlr.TerminalNode
	LAST_CODE_ITEM() antlr.TerminalNode
	AllCODE_ITEM() []antlr.TerminalNode
	CODE_ITEM(i int) antlr.TerminalNode

	// IsCharacteristicsContext differentiates from other interfaces.
	IsCharacteristicsContext()
}

type CharacteristicsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharacteristicsContext() *CharacteristicsContext {
	var p = new(CharacteristicsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_characteristics
	return p
}

func InitEmptyCharacteristicsContext(p *CharacteristicsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_characteristics
}

func (*CharacteristicsContext) IsCharacteristicsContext() {}

func NewCharacteristicsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharacteristicsContext {
	var p = new(CharacteristicsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_characteristics

	return p
}

func (s *CharacteristicsContext) GetParser() antlr.Parser { return s.parser }

func (s *CharacteristicsContext) KW_CHARACTERISTICS() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_CHARACTERISTICS, 0)
}

func (s *CharacteristicsContext) LAST_CODE_ITEM() antlr.TerminalNode {
	return s.GetToken(FSHParserLAST_CODE_ITEM, 0)
}

func (s *CharacteristicsContext) AllCODE_ITEM() []antlr.TerminalNode {
	return s.GetTokens(FSHParserCODE_ITEM)
}

func (s *CharacteristicsContext) CODE_ITEM(i int) antlr.TerminalNode {
	return s.GetToken(FSHParserCODE_ITEM, i)
}

func (s *CharacteristicsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharacteristicsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharacteristicsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitCharacteristics(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Characteristics() (localctx ICharacteristicsContext) {
	localctx = NewCharacteristicsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, FSHParserRULE_characteristics)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(502)
		p.Match(FSHParserKW_CHARACTERISTICS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(506)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FSHParserCODE_ITEM {
		{
			p.SetState(503)
			p.Match(FSHParserCODE_ITEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(508)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(509)
		p.Match(FSHParserLAST_CODE_ITEM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICardRuleContext is an interface to support dynamic dispatch.
type ICardRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	Path() IPathContext
	CARD() antlr.TerminalNode
	AllFlag() []IFlagContext
	Flag(i int) IFlagContext

	// IsCardRuleContext differentiates from other interfaces.
	IsCardRuleContext()
}

type CardRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCardRuleContext() *CardRuleContext {
	var p = new(CardRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_cardRule
	return p
}

func InitEmptyCardRuleContext(p *CardRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_cardRule
}

func (*CardRuleContext) IsCardRuleContext() {}

func NewCardRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CardRuleContext {
	var p = new(CardRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_cardRule

	return p
}

func (s *CardRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *CardRuleContext) STAR() antlr.TerminalNode {
	return s.GetToken(FSHParserSTAR, 0)
}

func (s *CardRuleContext) Path() IPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathContext)
}

func (s *CardRuleContext) CARD() antlr.TerminalNode {
	return s.GetToken(FSHParserCARD, 0)
}

func (s *CardRuleContext) AllFlag() []IFlagContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFlagContext); ok {
			len++
		}
	}

	tst := make([]IFlagContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFlagContext); ok {
			tst[i] = t.(IFlagContext)
			i++
		}
	}

	return tst
}

func (s *CardRuleContext) Flag(i int) IFlagContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlagContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlagContext)
}

func (s *CardRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CardRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CardRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitCardRule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) CardRule() (localctx ICardRuleContext) {
	localctx = NewCardRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, FSHParserRULE_cardRule)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(511)
		p.Match(FSHParserSTAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(512)
		p.Path()
	}
	{
		p.SetState(513)
		p.Match(FSHParserCARD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(517)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2113929216) != 0 {
		{
			p.SetState(514)
			p.Flag()
		}

		p.SetState(519)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFlagRuleContext is an interface to support dynamic dispatch.
type IFlagRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	AllPath() []IPathContext
	Path(i int) IPathContext
	AllKW_AND() []antlr.TerminalNode
	KW_AND(i int) antlr.TerminalNode
	AllFlag() []IFlagContext
	Flag(i int) IFlagContext

	// IsFlagRuleContext differentiates from other interfaces.
	IsFlagRuleContext()
}

type FlagRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlagRuleContext() *FlagRuleContext {
	var p = new(FlagRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_flagRule
	return p
}

func InitEmptyFlagRuleContext(p *FlagRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_flagRule
}

func (*FlagRuleContext) IsFlagRuleContext() {}

func NewFlagRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FlagRuleContext {
	var p = new(FlagRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_flagRule

	return p
}

func (s *FlagRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *FlagRuleContext) STAR() antlr.TerminalNode {
	return s.GetToken(FSHParserSTAR, 0)
}

func (s *FlagRuleContext) AllPath() []IPathContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPathContext); ok {
			len++
		}
	}

	tst := make([]IPathContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPathContext); ok {
			tst[i] = t.(IPathContext)
			i++
		}
	}

	return tst
}

func (s *FlagRuleContext) Path(i int) IPathContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathContext)
}

func (s *FlagRuleContext) AllKW_AND() []antlr.TerminalNode {
	return s.GetTokens(FSHParserKW_AND)
}

func (s *FlagRuleContext) KW_AND(i int) antlr.TerminalNode {
	return s.GetToken(FSHParserKW_AND, i)
}

func (s *FlagRuleContext) AllFlag() []IFlagContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFlagContext); ok {
			len++
		}
	}

	tst := make([]IFlagContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFlagContext); ok {
			tst[i] = t.(IFlagContext)
			i++
		}
	}

	return tst
}

func (s *FlagRuleContext) Flag(i int) IFlagContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlagContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlagContext)
}

func (s *FlagRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FlagRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FlagRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitFlagRule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) FlagRule() (localctx IFlagRuleContext) {
	localctx = NewFlagRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, FSHParserRULE_flagRule)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(520)
		p.Match(FSHParserSTAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(521)
		p.Path()
	}
	p.SetState(526)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FSHParserKW_AND {
		{
			p.SetState(522)
			p.Match(FSHParserKW_AND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(523)
			p.Path()
		}

		p.SetState(528)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(530)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2113929216) != 0) {
		{
			p.SetState(529)
			p.Flag()
		}

		p.SetState(532)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueSetRuleContext is an interface to support dynamic dispatch.
type IValueSetRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	Path() IPathContext
	KW_FROM() antlr.TerminalNode
	Name() INameContext
	Strength() IStrengthContext

	// IsValueSetRuleContext differentiates from other interfaces.
	IsValueSetRuleContext()
}

type ValueSetRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueSetRuleContext() *ValueSetRuleContext {
	var p = new(ValueSetRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_valueSetRule
	return p
}

func InitEmptyValueSetRuleContext(p *ValueSetRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_valueSetRule
}

func (*ValueSetRuleContext) IsValueSetRuleContext() {}

func NewValueSetRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueSetRuleContext {
	var p = new(ValueSetRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_valueSetRule

	return p
}

func (s *ValueSetRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueSetRuleContext) STAR() antlr.TerminalNode {
	return s.GetToken(FSHParserSTAR, 0)
}

func (s *ValueSetRuleContext) Path() IPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathContext)
}

func (s *ValueSetRuleContext) KW_FROM() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_FROM, 0)
}

func (s *ValueSetRuleContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *ValueSetRuleContext) Strength() IStrengthContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrengthContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrengthContext)
}

func (s *ValueSetRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueSetRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueSetRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitValueSetRule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) ValueSetRule() (localctx IValueSetRuleContext) {
	localctx = NewValueSetRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, FSHParserRULE_valueSetRule)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(534)
		p.Match(FSHParserSTAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(535)
		p.Path()
	}
	{
		p.SetState(536)
		p.Match(FSHParserKW_FROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(537)
		p.Name()
	}
	p.SetState(539)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&64424509440) != 0 {
		{
			p.SetState(538)
			p.Strength()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFixedValueRuleContext is an interface to support dynamic dispatch.
type IFixedValueRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	Path() IPathContext
	EQUAL() antlr.TerminalNode
	Value() IValueContext
	KW_EXACTLY() antlr.TerminalNode

	// IsFixedValueRuleContext differentiates from other interfaces.
	IsFixedValueRuleContext()
}

type FixedValueRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFixedValueRuleContext() *FixedValueRuleContext {
	var p = new(FixedValueRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_fixedValueRule
	return p
}

func InitEmptyFixedValueRuleContext(p *FixedValueRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_fixedValueRule
}

func (*FixedValueRuleContext) IsFixedValueRuleContext() {}

func NewFixedValueRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FixedValueRuleContext {
	var p = new(FixedValueRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_fixedValueRule

	return p
}

func (s *FixedValueRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *FixedValueRuleContext) STAR() antlr.TerminalNode {
	return s.GetToken(FSHParserSTAR, 0)
}

func (s *FixedValueRuleContext) Path() IPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathContext)
}

func (s *FixedValueRuleContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(FSHParserEQUAL, 0)
}

func (s *FixedValueRuleContext) Value() IValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *FixedValueRuleContext) KW_EXACTLY() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_EXACTLY, 0)
}

func (s *FixedValueRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FixedValueRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FixedValueRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitFixedValueRule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) FixedValueRule() (localctx IFixedValueRuleContext) {
	localctx = NewFixedValueRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, FSHParserRULE_fixedValueRule)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(541)
		p.Match(FSHParserSTAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(542)
		p.Path()
	}
	{
		p.SetState(543)
		p.Match(FSHParserEQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(544)
		p.Value()
	}
	p.SetState(546)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FSHParserKW_EXACTLY {
		{
			p.SetState(545)
			p.Match(FSHParserKW_EXACTLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContainsRuleContext is an interface to support dynamic dispatch.
type IContainsRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	Path() IPathContext
	KW_CONTAINS() antlr.TerminalNode
	AllItem() []IItemContext
	Item(i int) IItemContext
	AllKW_AND() []antlr.TerminalNode
	KW_AND(i int) antlr.TerminalNode

	// IsContainsRuleContext differentiates from other interfaces.
	IsContainsRuleContext()
}

type ContainsRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContainsRuleContext() *ContainsRuleContext {
	var p = new(ContainsRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_containsRule
	return p
}

func InitEmptyContainsRuleContext(p *ContainsRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_containsRule
}

func (*ContainsRuleContext) IsContainsRuleContext() {}

func NewContainsRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContainsRuleContext {
	var p = new(ContainsRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_containsRule

	return p
}

func (s *ContainsRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *ContainsRuleContext) STAR() antlr.TerminalNode {
	return s.GetToken(FSHParserSTAR, 0)
}

func (s *ContainsRuleContext) Path() IPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathContext)
}

func (s *ContainsRuleContext) KW_CONTAINS() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_CONTAINS, 0)
}

func (s *ContainsRuleContext) AllItem() []IItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IItemContext); ok {
			len++
		}
	}

	tst := make([]IItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IItemContext); ok {
			tst[i] = t.(IItemContext)
			i++
		}
	}

	return tst
}

func (s *ContainsRuleContext) Item(i int) IItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IItemContext)
}

func (s *ContainsRuleContext) AllKW_AND() []antlr.TerminalNode {
	return s.GetTokens(FSHParserKW_AND)
}

func (s *ContainsRuleContext) KW_AND(i int) antlr.TerminalNode {
	return s.GetToken(FSHParserKW_AND, i)
}

func (s *ContainsRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContainsRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContainsRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitContainsRule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) ContainsRule() (localctx IContainsRuleContext) {
	localctx = NewContainsRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, FSHParserRULE_containsRule)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(548)
		p.Match(FSHParserSTAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(549)
		p.Path()
	}
	{
		p.SetState(550)
		p.Match(FSHParserKW_CONTAINS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(551)
		p.Item()
	}
	p.SetState(556)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FSHParserKW_AND {
		{
			p.SetState(552)
			p.Match(FSHParserKW_AND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(553)
			p.Item()
		}

		p.SetState(558)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOnlyRuleContext is an interface to support dynamic dispatch.
type IOnlyRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	Path() IPathContext
	KW_ONLY() antlr.TerminalNode
	AllTargetType() []ITargetTypeContext
	TargetType(i int) ITargetTypeContext
	AllKW_OR() []antlr.TerminalNode
	KW_OR(i int) antlr.TerminalNode

	// IsOnlyRuleContext differentiates from other interfaces.
	IsOnlyRuleContext()
}

type OnlyRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnlyRuleContext() *OnlyRuleContext {
	var p = new(OnlyRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_onlyRule
	return p
}

func InitEmptyOnlyRuleContext(p *OnlyRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_onlyRule
}

func (*OnlyRuleContext) IsOnlyRuleContext() {}

func NewOnlyRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnlyRuleContext {
	var p = new(OnlyRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_onlyRule

	return p
}

func (s *OnlyRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *OnlyRuleContext) STAR() antlr.TerminalNode {
	return s.GetToken(FSHParserSTAR, 0)
}

func (s *OnlyRuleContext) Path() IPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathContext)
}

func (s *OnlyRuleContext) KW_ONLY() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_ONLY, 0)
}

func (s *OnlyRuleContext) AllTargetType() []ITargetTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITargetTypeContext); ok {
			len++
		}
	}

	tst := make([]ITargetTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITargetTypeContext); ok {
			tst[i] = t.(ITargetTypeContext)
			i++
		}
	}

	return tst
}

func (s *OnlyRuleContext) TargetType(i int) ITargetTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetTypeContext)
}

func (s *OnlyRuleContext) AllKW_OR() []antlr.TerminalNode {
	return s.GetTokens(FSHParserKW_OR)
}

func (s *OnlyRuleContext) KW_OR(i int) antlr.TerminalNode {
	return s.GetToken(FSHParserKW_OR, i)
}

func (s *OnlyRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnlyRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnlyRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitOnlyRule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) OnlyRule() (localctx IOnlyRuleContext) {
	localctx = NewOnlyRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, FSHParserRULE_onlyRule)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(559)
		p.Match(FSHParserSTAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(560)
		p.Path()
	}
	{
		p.SetState(561)
		p.Match(FSHParserKW_ONLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(562)
		p.TargetType()
	}
	p.SetState(567)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FSHParserKW_OR {
		{
			p.SetState(563)
			p.Match(FSHParserKW_OR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(564)
			p.TargetType()
		}

		p.SetState(569)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObeysRuleContext is an interface to support dynamic dispatch.
type IObeysRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	KW_OBEYS() antlr.TerminalNode
	AllName() []INameContext
	Name(i int) INameContext
	Path() IPathContext
	AllKW_AND() []antlr.TerminalNode
	KW_AND(i int) antlr.TerminalNode

	// IsObeysRuleContext differentiates from other interfaces.
	IsObeysRuleContext()
}

type ObeysRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObeysRuleContext() *ObeysRuleContext {
	var p = new(ObeysRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_obeysRule
	return p
}

func InitEmptyObeysRuleContext(p *ObeysRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_obeysRule
}

func (*ObeysRuleContext) IsObeysRuleContext() {}

func NewObeysRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObeysRuleContext {
	var p = new(ObeysRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_obeysRule

	return p
}

func (s *ObeysRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *ObeysRuleContext) STAR() antlr.TerminalNode {
	return s.GetToken(FSHParserSTAR, 0)
}

func (s *ObeysRuleContext) KW_OBEYS() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_OBEYS, 0)
}

func (s *ObeysRuleContext) AllName() []INameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INameContext); ok {
			len++
		}
	}

	tst := make([]INameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INameContext); ok {
			tst[i] = t.(INameContext)
			i++
		}
	}

	return tst
}

func (s *ObeysRuleContext) Name(i int) INameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *ObeysRuleContext) Path() IPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathContext)
}

func (s *ObeysRuleContext) AllKW_AND() []antlr.TerminalNode {
	return s.GetTokens(FSHParserKW_AND)
}

func (s *ObeysRuleContext) KW_AND(i int) antlr.TerminalNode {
	return s.GetToken(FSHParserKW_AND, i)
}

func (s *ObeysRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObeysRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObeysRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitObeysRule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) ObeysRule() (localctx IObeysRuleContext) {
	localctx = NewObeysRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, FSHParserRULE_obeysRule)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(570)
		p.Match(FSHParserSTAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(572)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(571)
			p.Path()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(574)
		p.Match(FSHParserKW_OBEYS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(575)
		p.Name()
	}
	p.SetState(580)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FSHParserKW_AND {
		{
			p.SetState(576)
			p.Match(FSHParserKW_AND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(577)
			p.Name()
		}

		p.SetState(582)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaretValueRuleContext is an interface to support dynamic dispatch.
type ICaretValueRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	CaretPath() ICaretPathContext
	EQUAL() antlr.TerminalNode
	Value() IValueContext
	Path() IPathContext

	// IsCaretValueRuleContext differentiates from other interfaces.
	IsCaretValueRuleContext()
}

type CaretValueRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaretValueRuleContext() *CaretValueRuleContext {
	var p = new(CaretValueRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_caretValueRule
	return p
}

func InitEmptyCaretValueRuleContext(p *CaretValueRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_caretValueRule
}

func (*CaretValueRuleContext) IsCaretValueRuleContext() {}

func NewCaretValueRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaretValueRuleContext {
	var p = new(CaretValueRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_caretValueRule

	return p
}

func (s *CaretValueRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *CaretValueRuleContext) STAR() antlr.TerminalNode {
	return s.GetToken(FSHParserSTAR, 0)
}

func (s *CaretValueRuleContext) CaretPath() ICaretPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaretPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaretPathContext)
}

func (s *CaretValueRuleContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(FSHParserEQUAL, 0)
}

func (s *CaretValueRuleContext) Value() IValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *CaretValueRuleContext) Path() IPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathContext)
}

func (s *CaretValueRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaretValueRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaretValueRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitCaretValueRule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) CaretValueRule() (localctx ICaretValueRuleContext) {
	localctx = NewCaretValueRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, FSHParserRULE_caretValueRule)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(583)
		p.Match(FSHParserSTAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(585)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-26)) & ^0x3f) == 0 && ((int64(1)<<(_la-26))&141579385830463) != 0 {
		{
			p.SetState(584)
			p.Path()
		}

	}
	{
		p.SetState(587)
		p.CaretPath()
	}
	{
		p.SetState(588)
		p.Match(FSHParserEQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(589)
		p.Value()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICodeCaretValueRuleContext is an interface to support dynamic dispatch.
type ICodeCaretValueRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	CaretPath() ICaretPathContext
	EQUAL() antlr.TerminalNode
	Value() IValueContext
	AllCODE() []antlr.TerminalNode
	CODE(i int) antlr.TerminalNode

	// IsCodeCaretValueRuleContext differentiates from other interfaces.
	IsCodeCaretValueRuleContext()
}

type CodeCaretValueRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodeCaretValueRuleContext() *CodeCaretValueRuleContext {
	var p = new(CodeCaretValueRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_codeCaretValueRule
	return p
}

func InitEmptyCodeCaretValueRuleContext(p *CodeCaretValueRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_codeCaretValueRule
}

func (*CodeCaretValueRuleContext) IsCodeCaretValueRuleContext() {}

func NewCodeCaretValueRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodeCaretValueRuleContext {
	var p = new(CodeCaretValueRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_codeCaretValueRule

	return p
}

func (s *CodeCaretValueRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *CodeCaretValueRuleContext) STAR() antlr.TerminalNode {
	return s.GetToken(FSHParserSTAR, 0)
}

func (s *CodeCaretValueRuleContext) CaretPath() ICaretPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaretPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaretPathContext)
}

func (s *CodeCaretValueRuleContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(FSHParserEQUAL, 0)
}

func (s *CodeCaretValueRuleContext) Value() IValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *CodeCaretValueRuleContext) AllCODE() []antlr.TerminalNode {
	return s.GetTokens(FSHParserCODE)
}

func (s *CodeCaretValueRuleContext) CODE(i int) antlr.TerminalNode {
	return s.GetToken(FSHParserCODE, i)
}

func (s *CodeCaretValueRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeCaretValueRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodeCaretValueRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitCodeCaretValueRule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) CodeCaretValueRule() (localctx ICodeCaretValueRuleContext) {
	localctx = NewCodeCaretValueRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, FSHParserRULE_codeCaretValueRule)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(591)
		p.Match(FSHParserSTAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(595)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FSHParserCODE {
		{
			p.SetState(592)
			p.Match(FSHParserCODE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(597)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(598)
		p.CaretPath()
	}
	{
		p.SetState(599)
		p.Match(FSHParserEQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(600)
		p.Value()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMappingRuleContext is an interface to support dynamic dispatch.
type IMappingRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	ARROW() antlr.TerminalNode
	AllSTRING() []antlr.TerminalNode
	STRING(i int) antlr.TerminalNode
	Path() IPathContext
	CODE() antlr.TerminalNode

	// IsMappingRuleContext differentiates from other interfaces.
	IsMappingRuleContext()
}

type MappingRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMappingRuleContext() *MappingRuleContext {
	var p = new(MappingRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_mappingRule
	return p
}

func InitEmptyMappingRuleContext(p *MappingRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_mappingRule
}

func (*MappingRuleContext) IsMappingRuleContext() {}

func NewMappingRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MappingRuleContext {
	var p = new(MappingRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_mappingRule

	return p
}

func (s *MappingRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *MappingRuleContext) STAR() antlr.TerminalNode {
	return s.GetToken(FSHParserSTAR, 0)
}

func (s *MappingRuleContext) ARROW() antlr.TerminalNode {
	return s.GetToken(FSHParserARROW, 0)
}

func (s *MappingRuleContext) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(FSHParserSTRING)
}

func (s *MappingRuleContext) STRING(i int) antlr.TerminalNode {
	return s.GetToken(FSHParserSTRING, i)
}

func (s *MappingRuleContext) Path() IPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathContext)
}

func (s *MappingRuleContext) CODE() antlr.TerminalNode {
	return s.GetToken(FSHParserCODE, 0)
}

func (s *MappingRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MappingRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MappingRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitMappingRule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) MappingRule() (localctx IMappingRuleContext) {
	localctx = NewMappingRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, FSHParserRULE_mappingRule)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(602)
		p.Match(FSHParserSTAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(604)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-26)) & ^0x3f) == 0 && ((int64(1)<<(_la-26))&141579385830463) != 0 {
		{
			p.SetState(603)
			p.Path()
		}

	}
	{
		p.SetState(606)
		p.Match(FSHParserARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(607)
		p.Match(FSHParserSTRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(609)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FSHParserSTRING {
		{
			p.SetState(608)
			p.Match(FSHParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(612)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FSHParserCODE {
		{
			p.SetState(611)
			p.Match(FSHParserCODE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertRuleContext is an interface to support dynamic dispatch.
type IInsertRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	KW_INSERT() antlr.TerminalNode
	RULESET_REFERENCE() antlr.TerminalNode
	ParamRuleSetRef() IParamRuleSetRefContext
	Path() IPathContext

	// IsInsertRuleContext differentiates from other interfaces.
	IsInsertRuleContext()
}

type InsertRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertRuleContext() *InsertRuleContext {
	var p = new(InsertRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_insertRule
	return p
}

func InitEmptyInsertRuleContext(p *InsertRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_insertRule
}

func (*InsertRuleContext) IsInsertRuleContext() {}

func NewInsertRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertRuleContext {
	var p = new(InsertRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_insertRule

	return p
}

func (s *InsertRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertRuleContext) STAR() antlr.TerminalNode {
	return s.GetToken(FSHParserSTAR, 0)
}

func (s *InsertRuleContext) KW_INSERT() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_INSERT, 0)
}

func (s *InsertRuleContext) RULESET_REFERENCE() antlr.TerminalNode {
	return s.GetToken(FSHParserRULESET_REFERENCE, 0)
}

func (s *InsertRuleContext) ParamRuleSetRef() IParamRuleSetRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamRuleSetRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamRuleSetRefContext)
}

func (s *InsertRuleContext) Path() IPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathContext)
}

func (s *InsertRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitInsertRule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) InsertRule() (localctx IInsertRuleContext) {
	localctx = NewInsertRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, FSHParserRULE_insertRule)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(614)
		p.Match(FSHParserSTAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(616)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-26)) & ^0x3f) == 0 && ((int64(1)<<(_la-26))&141579385830463) != 0 {
		{
			p.SetState(615)
			p.Path()
		}

	}
	{
		p.SetState(618)
		p.Match(FSHParserKW_INSERT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(621)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FSHParserRULESET_REFERENCE:
		{
			p.SetState(619)
			p.Match(FSHParserRULESET_REFERENCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FSHParserPARAM_RULESET_REFERENCE:
		{
			p.SetState(620)
			p.ParamRuleSetRef()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICodeInsertRuleContext is an interface to support dynamic dispatch.
type ICodeInsertRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	KW_INSERT() antlr.TerminalNode
	RULESET_REFERENCE() antlr.TerminalNode
	ParamRuleSetRef() IParamRuleSetRefContext
	AllCODE() []antlr.TerminalNode
	CODE(i int) antlr.TerminalNode

	// IsCodeInsertRuleContext differentiates from other interfaces.
	IsCodeInsertRuleContext()
}

type CodeInsertRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodeInsertRuleContext() *CodeInsertRuleContext {
	var p = new(CodeInsertRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_codeInsertRule
	return p
}

func InitEmptyCodeInsertRuleContext(p *CodeInsertRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_codeInsertRule
}

func (*CodeInsertRuleContext) IsCodeInsertRuleContext() {}

func NewCodeInsertRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodeInsertRuleContext {
	var p = new(CodeInsertRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_codeInsertRule

	return p
}

func (s *CodeInsertRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *CodeInsertRuleContext) STAR() antlr.TerminalNode {
	return s.GetToken(FSHParserSTAR, 0)
}

func (s *CodeInsertRuleContext) KW_INSERT() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_INSERT, 0)
}

func (s *CodeInsertRuleContext) RULESET_REFERENCE() antlr.TerminalNode {
	return s.GetToken(FSHParserRULESET_REFERENCE, 0)
}

func (s *CodeInsertRuleContext) ParamRuleSetRef() IParamRuleSetRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamRuleSetRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamRuleSetRefContext)
}

func (s *CodeInsertRuleContext) AllCODE() []antlr.TerminalNode {
	return s.GetTokens(FSHParserCODE)
}

func (s *CodeInsertRuleContext) CODE(i int) antlr.TerminalNode {
	return s.GetToken(FSHParserCODE, i)
}

func (s *CodeInsertRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeInsertRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodeInsertRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitCodeInsertRule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) CodeInsertRule() (localctx ICodeInsertRuleContext) {
	localctx = NewCodeInsertRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, FSHParserRULE_codeInsertRule)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(623)
		p.Match(FSHParserSTAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(627)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FSHParserCODE {
		{
			p.SetState(624)
			p.Match(FSHParserCODE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(629)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(630)
		p.Match(FSHParserKW_INSERT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(633)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FSHParserRULESET_REFERENCE:
		{
			p.SetState(631)
			p.Match(FSHParserRULESET_REFERENCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FSHParserPARAM_RULESET_REFERENCE:
		{
			p.SetState(632)
			p.ParamRuleSetRef()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddCRElementRuleContext is an interface to support dynamic dispatch.
type IAddCRElementRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	Path() IPathContext
	CARD() antlr.TerminalNode
	KW_CONTENTREFERENCE() antlr.TerminalNode
	AllSTRING() []antlr.TerminalNode
	STRING(i int) antlr.TerminalNode
	SEQUENCE() antlr.TerminalNode
	CODE() antlr.TerminalNode
	AllFlag() []IFlagContext
	Flag(i int) IFlagContext
	MULTILINE_STRING() antlr.TerminalNode

	// IsAddCRElementRuleContext differentiates from other interfaces.
	IsAddCRElementRuleContext()
}

type AddCRElementRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddCRElementRuleContext() *AddCRElementRuleContext {
	var p = new(AddCRElementRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_addCRElementRule
	return p
}

func InitEmptyAddCRElementRuleContext(p *AddCRElementRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_addCRElementRule
}

func (*AddCRElementRuleContext) IsAddCRElementRuleContext() {}

func NewAddCRElementRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddCRElementRuleContext {
	var p = new(AddCRElementRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_addCRElementRule

	return p
}

func (s *AddCRElementRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *AddCRElementRuleContext) STAR() antlr.TerminalNode {
	return s.GetToken(FSHParserSTAR, 0)
}

func (s *AddCRElementRuleContext) Path() IPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathContext)
}

func (s *AddCRElementRuleContext) CARD() antlr.TerminalNode {
	return s.GetToken(FSHParserCARD, 0)
}

func (s *AddCRElementRuleContext) KW_CONTENTREFERENCE() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_CONTENTREFERENCE, 0)
}

func (s *AddCRElementRuleContext) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(FSHParserSTRING)
}

func (s *AddCRElementRuleContext) STRING(i int) antlr.TerminalNode {
	return s.GetToken(FSHParserSTRING, i)
}

func (s *AddCRElementRuleContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(FSHParserSEQUENCE, 0)
}

func (s *AddCRElementRuleContext) CODE() antlr.TerminalNode {
	return s.GetToken(FSHParserCODE, 0)
}

func (s *AddCRElementRuleContext) AllFlag() []IFlagContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFlagContext); ok {
			len++
		}
	}

	tst := make([]IFlagContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFlagContext); ok {
			tst[i] = t.(IFlagContext)
			i++
		}
	}

	return tst
}

func (s *AddCRElementRuleContext) Flag(i int) IFlagContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlagContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlagContext)
}

func (s *AddCRElementRuleContext) MULTILINE_STRING() antlr.TerminalNode {
	return s.GetToken(FSHParserMULTILINE_STRING, 0)
}

func (s *AddCRElementRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddCRElementRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddCRElementRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitAddCRElementRule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) AddCRElementRule() (localctx IAddCRElementRuleContext) {
	localctx = NewAddCRElementRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, FSHParserRULE_addCRElementRule)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(635)
		p.Match(FSHParserSTAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(636)
		p.Path()
	}
	{
		p.SetState(637)
		p.Match(FSHParserCARD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(641)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2113929216) != 0 {
		{
			p.SetState(638)
			p.Flag()
		}

		p.SetState(643)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(644)
		p.Match(FSHParserKW_CONTENTREFERENCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(645)
		_la = p.GetTokenStream().LA(1)

		if !(_la == FSHParserCODE || _la == FSHParserSEQUENCE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(646)
		p.Match(FSHParserSTRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(648)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FSHParserSTRING || _la == FSHParserMULTILINE_STRING {
		{
			p.SetState(647)
			_la = p.GetTokenStream().LA(1)

			if !(_la == FSHParserSTRING || _la == FSHParserMULTILINE_STRING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddElementRuleContext is an interface to support dynamic dispatch.
type IAddElementRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	Path() IPathContext
	CARD() antlr.TerminalNode
	AllTargetType() []ITargetTypeContext
	TargetType(i int) ITargetTypeContext
	AllSTRING() []antlr.TerminalNode
	STRING(i int) antlr.TerminalNode
	AllFlag() []IFlagContext
	Flag(i int) IFlagContext
	AllKW_OR() []antlr.TerminalNode
	KW_OR(i int) antlr.TerminalNode
	MULTILINE_STRING() antlr.TerminalNode

	// IsAddElementRuleContext differentiates from other interfaces.
	IsAddElementRuleContext()
}

type AddElementRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddElementRuleContext() *AddElementRuleContext {
	var p = new(AddElementRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_addElementRule
	return p
}

func InitEmptyAddElementRuleContext(p *AddElementRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_addElementRule
}

func (*AddElementRuleContext) IsAddElementRuleContext() {}

func NewAddElementRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddElementRuleContext {
	var p = new(AddElementRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_addElementRule

	return p
}

func (s *AddElementRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *AddElementRuleContext) STAR() antlr.TerminalNode {
	return s.GetToken(FSHParserSTAR, 0)
}

func (s *AddElementRuleContext) Path() IPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathContext)
}

func (s *AddElementRuleContext) CARD() antlr.TerminalNode {
	return s.GetToken(FSHParserCARD, 0)
}

func (s *AddElementRuleContext) AllTargetType() []ITargetTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITargetTypeContext); ok {
			len++
		}
	}

	tst := make([]ITargetTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITargetTypeContext); ok {
			tst[i] = t.(ITargetTypeContext)
			i++
		}
	}

	return tst
}

func (s *AddElementRuleContext) TargetType(i int) ITargetTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetTypeContext)
}

func (s *AddElementRuleContext) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(FSHParserSTRING)
}

func (s *AddElementRuleContext) STRING(i int) antlr.TerminalNode {
	return s.GetToken(FSHParserSTRING, i)
}

func (s *AddElementRuleContext) AllFlag() []IFlagContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFlagContext); ok {
			len++
		}
	}

	tst := make([]IFlagContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFlagContext); ok {
			tst[i] = t.(IFlagContext)
			i++
		}
	}

	return tst
}

func (s *AddElementRuleContext) Flag(i int) IFlagContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlagContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlagContext)
}

func (s *AddElementRuleContext) AllKW_OR() []antlr.TerminalNode {
	return s.GetTokens(FSHParserKW_OR)
}

func (s *AddElementRuleContext) KW_OR(i int) antlr.TerminalNode {
	return s.GetToken(FSHParserKW_OR, i)
}

func (s *AddElementRuleContext) MULTILINE_STRING() antlr.TerminalNode {
	return s.GetToken(FSHParserMULTILINE_STRING, 0)
}

func (s *AddElementRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddElementRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddElementRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitAddElementRule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) AddElementRule() (localctx IAddElementRuleContext) {
	localctx = NewAddElementRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, FSHParserRULE_addElementRule)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(650)
		p.Match(FSHParserSTAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(651)
		p.Path()
	}
	{
		p.SetState(652)
		p.Match(FSHParserCARD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(656)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(653)
				p.Flag()
			}

		}
		p.SetState(658)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(659)
		p.TargetType()
	}
	p.SetState(664)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FSHParserKW_OR {
		{
			p.SetState(660)
			p.Match(FSHParserKW_OR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(661)
			p.TargetType()
		}

		p.SetState(666)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(667)
		p.Match(FSHParserSTRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(669)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FSHParserSTRING || _la == FSHParserMULTILINE_STRING {
		{
			p.SetState(668)
			_la = p.GetTokenStream().LA(1)

			if !(_la == FSHParserSTRING || _la == FSHParserMULTILINE_STRING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathRuleContext is an interface to support dynamic dispatch.
type IPathRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	Path() IPathContext

	// IsPathRuleContext differentiates from other interfaces.
	IsPathRuleContext()
}

type PathRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathRuleContext() *PathRuleContext {
	var p = new(PathRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_pathRule
	return p
}

func InitEmptyPathRuleContext(p *PathRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_pathRule
}

func (*PathRuleContext) IsPathRuleContext() {}

func NewPathRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathRuleContext {
	var p = new(PathRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_pathRule

	return p
}

func (s *PathRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *PathRuleContext) STAR() antlr.TerminalNode {
	return s.GetToken(FSHParserSTAR, 0)
}

func (s *PathRuleContext) Path() IPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathContext)
}

func (s *PathRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitPathRule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) PathRule() (localctx IPathRuleContext) {
	localctx = NewPathRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, FSHParserRULE_pathRule)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(671)
		p.Match(FSHParserSTAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(672)
		p.Path()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVsComponentContext is an interface to support dynamic dispatch.
type IVsComponentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	VsConceptComponent() IVsConceptComponentContext
	VsFilterComponent() IVsFilterComponentContext
	KW_INCLUDE() antlr.TerminalNode
	KW_EXCLUDE() antlr.TerminalNode

	// IsVsComponentContext differentiates from other interfaces.
	IsVsComponentContext()
}

type VsComponentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVsComponentContext() *VsComponentContext {
	var p = new(VsComponentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_vsComponent
	return p
}

func InitEmptyVsComponentContext(p *VsComponentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_vsComponent
}

func (*VsComponentContext) IsVsComponentContext() {}

func NewVsComponentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VsComponentContext {
	var p = new(VsComponentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_vsComponent

	return p
}

func (s *VsComponentContext) GetParser() antlr.Parser { return s.parser }

func (s *VsComponentContext) STAR() antlr.TerminalNode {
	return s.GetToken(FSHParserSTAR, 0)
}

func (s *VsComponentContext) VsConceptComponent() IVsConceptComponentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVsConceptComponentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVsConceptComponentContext)
}

func (s *VsComponentContext) VsFilterComponent() IVsFilterComponentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVsFilterComponentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVsFilterComponentContext)
}

func (s *VsComponentContext) KW_INCLUDE() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_INCLUDE, 0)
}

func (s *VsComponentContext) KW_EXCLUDE() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_EXCLUDE, 0)
}

func (s *VsComponentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsComponentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VsComponentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitVsComponent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) VsComponent() (localctx IVsComponentContext) {
	localctx = NewVsComponentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, FSHParserRULE_vsComponent)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(674)
		p.Match(FSHParserSTAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(676)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FSHParserKW_INCLUDE || _la == FSHParserKW_EXCLUDE {
		{
			p.SetState(675)
			_la = p.GetTokenStream().LA(1)

			if !(_la == FSHParserKW_INCLUDE || _la == FSHParserKW_EXCLUDE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(680)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FSHParserCODE:
		{
			p.SetState(678)
			p.VsConceptComponent()
		}

	case FSHParserKW_CODES:
		{
			p.SetState(679)
			p.VsFilterComponent()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVsConceptComponentContext is an interface to support dynamic dispatch.
type IVsConceptComponentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Code() ICodeContext
	VsComponentFrom() IVsComponentFromContext

	// IsVsConceptComponentContext differentiates from other interfaces.
	IsVsConceptComponentContext()
}

type VsConceptComponentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVsConceptComponentContext() *VsConceptComponentContext {
	var p = new(VsConceptComponentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_vsConceptComponent
	return p
}

func InitEmptyVsConceptComponentContext(p *VsConceptComponentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_vsConceptComponent
}

func (*VsConceptComponentContext) IsVsConceptComponentContext() {}

func NewVsConceptComponentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VsConceptComponentContext {
	var p = new(VsConceptComponentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_vsConceptComponent

	return p
}

func (s *VsConceptComponentContext) GetParser() antlr.Parser { return s.parser }

func (s *VsConceptComponentContext) Code() ICodeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeContext)
}

func (s *VsConceptComponentContext) VsComponentFrom() IVsComponentFromContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVsComponentFromContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVsComponentFromContext)
}

func (s *VsConceptComponentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsConceptComponentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VsConceptComponentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitVsConceptComponent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) VsConceptComponent() (localctx IVsConceptComponentContext) {
	localctx = NewVsConceptComponentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, FSHParserRULE_vsConceptComponent)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(682)
		p.Code()
	}
	p.SetState(684)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FSHParserKW_FROM {
		{
			p.SetState(683)
			p.VsComponentFrom()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVsFilterComponentContext is an interface to support dynamic dispatch.
type IVsFilterComponentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_CODES() antlr.TerminalNode
	VsComponentFrom() IVsComponentFromContext
	KW_WHERE() antlr.TerminalNode
	VsFilterList() IVsFilterListContext

	// IsVsFilterComponentContext differentiates from other interfaces.
	IsVsFilterComponentContext()
}

type VsFilterComponentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVsFilterComponentContext() *VsFilterComponentContext {
	var p = new(VsFilterComponentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_vsFilterComponent
	return p
}

func InitEmptyVsFilterComponentContext(p *VsFilterComponentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_vsFilterComponent
}

func (*VsFilterComponentContext) IsVsFilterComponentContext() {}

func NewVsFilterComponentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VsFilterComponentContext {
	var p = new(VsFilterComponentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_vsFilterComponent

	return p
}

func (s *VsFilterComponentContext) GetParser() antlr.Parser { return s.parser }

func (s *VsFilterComponentContext) KW_CODES() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_CODES, 0)
}

func (s *VsFilterComponentContext) VsComponentFrom() IVsComponentFromContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVsComponentFromContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVsComponentFromContext)
}

func (s *VsFilterComponentContext) KW_WHERE() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_WHERE, 0)
}

func (s *VsFilterComponentContext) VsFilterList() IVsFilterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVsFilterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVsFilterListContext)
}

func (s *VsFilterComponentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsFilterComponentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VsFilterComponentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitVsFilterComponent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) VsFilterComponent() (localctx IVsFilterComponentContext) {
	localctx = NewVsFilterComponentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, FSHParserRULE_vsFilterComponent)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(686)
		p.Match(FSHParserKW_CODES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(687)
		p.VsComponentFrom()
	}
	p.SetState(690)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FSHParserKW_WHERE {
		{
			p.SetState(688)
			p.Match(FSHParserKW_WHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(689)
			p.VsFilterList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVsComponentFromContext is an interface to support dynamic dispatch.
type IVsComponentFromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_FROM() antlr.TerminalNode
	VsFromSystem() IVsFromSystemContext
	VsFromValueset() IVsFromValuesetContext
	KW_AND() antlr.TerminalNode

	// IsVsComponentFromContext differentiates from other interfaces.
	IsVsComponentFromContext()
}

type VsComponentFromContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVsComponentFromContext() *VsComponentFromContext {
	var p = new(VsComponentFromContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_vsComponentFrom
	return p
}

func InitEmptyVsComponentFromContext(p *VsComponentFromContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_vsComponentFrom
}

func (*VsComponentFromContext) IsVsComponentFromContext() {}

func NewVsComponentFromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VsComponentFromContext {
	var p = new(VsComponentFromContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_vsComponentFrom

	return p
}

func (s *VsComponentFromContext) GetParser() antlr.Parser { return s.parser }

func (s *VsComponentFromContext) KW_FROM() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_FROM, 0)
}

func (s *VsComponentFromContext) VsFromSystem() IVsFromSystemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVsFromSystemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVsFromSystemContext)
}

func (s *VsComponentFromContext) VsFromValueset() IVsFromValuesetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVsFromValuesetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVsFromValuesetContext)
}

func (s *VsComponentFromContext) KW_AND() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_AND, 0)
}

func (s *VsComponentFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsComponentFromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VsComponentFromContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitVsComponentFrom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) VsComponentFrom() (localctx IVsComponentFromContext) {
	localctx = NewVsComponentFromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, FSHParserRULE_vsComponentFrom)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(692)
		p.Match(FSHParserKW_FROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(703)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FSHParserKW_SYSTEM:
		{
			p.SetState(693)
			p.VsFromSystem()
		}
		p.SetState(696)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FSHParserKW_AND {
			{
				p.SetState(694)
				p.Match(FSHParserKW_AND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(695)
				p.VsFromValueset()
			}

		}

	case FSHParserKW_VSREFERENCE:
		{
			p.SetState(698)
			p.VsFromValueset()
		}
		p.SetState(701)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FSHParserKW_AND {
			{
				p.SetState(699)
				p.Match(FSHParserKW_AND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(700)
				p.VsFromSystem()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVsFromSystemContext is an interface to support dynamic dispatch.
type IVsFromSystemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_SYSTEM() antlr.TerminalNode
	Name() INameContext

	// IsVsFromSystemContext differentiates from other interfaces.
	IsVsFromSystemContext()
}

type VsFromSystemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVsFromSystemContext() *VsFromSystemContext {
	var p = new(VsFromSystemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_vsFromSystem
	return p
}

func InitEmptyVsFromSystemContext(p *VsFromSystemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_vsFromSystem
}

func (*VsFromSystemContext) IsVsFromSystemContext() {}

func NewVsFromSystemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VsFromSystemContext {
	var p = new(VsFromSystemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_vsFromSystem

	return p
}

func (s *VsFromSystemContext) GetParser() antlr.Parser { return s.parser }

func (s *VsFromSystemContext) KW_SYSTEM() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_SYSTEM, 0)
}

func (s *VsFromSystemContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *VsFromSystemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsFromSystemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VsFromSystemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitVsFromSystem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) VsFromSystem() (localctx IVsFromSystemContext) {
	localctx = NewVsFromSystemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, FSHParserRULE_vsFromSystem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(705)
		p.Match(FSHParserKW_SYSTEM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(706)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVsFromValuesetContext is an interface to support dynamic dispatch.
type IVsFromValuesetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_VSREFERENCE() antlr.TerminalNode
	AllName() []INameContext
	Name(i int) INameContext
	AllKW_AND() []antlr.TerminalNode
	KW_AND(i int) antlr.TerminalNode

	// IsVsFromValuesetContext differentiates from other interfaces.
	IsVsFromValuesetContext()
}

type VsFromValuesetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVsFromValuesetContext() *VsFromValuesetContext {
	var p = new(VsFromValuesetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_vsFromValueset
	return p
}

func InitEmptyVsFromValuesetContext(p *VsFromValuesetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_vsFromValueset
}

func (*VsFromValuesetContext) IsVsFromValuesetContext() {}

func NewVsFromValuesetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VsFromValuesetContext {
	var p = new(VsFromValuesetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_vsFromValueset

	return p
}

func (s *VsFromValuesetContext) GetParser() antlr.Parser { return s.parser }

func (s *VsFromValuesetContext) KW_VSREFERENCE() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_VSREFERENCE, 0)
}

func (s *VsFromValuesetContext) AllName() []INameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INameContext); ok {
			len++
		}
	}

	tst := make([]INameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INameContext); ok {
			tst[i] = t.(INameContext)
			i++
		}
	}

	return tst
}

func (s *VsFromValuesetContext) Name(i int) INameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *VsFromValuesetContext) AllKW_AND() []antlr.TerminalNode {
	return s.GetTokens(FSHParserKW_AND)
}

func (s *VsFromValuesetContext) KW_AND(i int) antlr.TerminalNode {
	return s.GetToken(FSHParserKW_AND, i)
}

func (s *VsFromValuesetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsFromValuesetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VsFromValuesetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitVsFromValueset(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) VsFromValueset() (localctx IVsFromValuesetContext) {
	localctx = NewVsFromValuesetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, FSHParserRULE_vsFromValueset)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(708)
		p.Match(FSHParserKW_VSREFERENCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(709)
		p.Name()
	}
	p.SetState(714)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(710)
				p.Match(FSHParserKW_AND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(711)
				p.Name()
			}

		}
		p.SetState(716)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVsFilterListContext is an interface to support dynamic dispatch.
type IVsFilterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVsFilterDefinition() []IVsFilterDefinitionContext
	VsFilterDefinition(i int) IVsFilterDefinitionContext
	AllKW_AND() []antlr.TerminalNode
	KW_AND(i int) antlr.TerminalNode

	// IsVsFilterListContext differentiates from other interfaces.
	IsVsFilterListContext()
}

type VsFilterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVsFilterListContext() *VsFilterListContext {
	var p = new(VsFilterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_vsFilterList
	return p
}

func InitEmptyVsFilterListContext(p *VsFilterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_vsFilterList
}

func (*VsFilterListContext) IsVsFilterListContext() {}

func NewVsFilterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VsFilterListContext {
	var p = new(VsFilterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_vsFilterList

	return p
}

func (s *VsFilterListContext) GetParser() antlr.Parser { return s.parser }

func (s *VsFilterListContext) AllVsFilterDefinition() []IVsFilterDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVsFilterDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IVsFilterDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVsFilterDefinitionContext); ok {
			tst[i] = t.(IVsFilterDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *VsFilterListContext) VsFilterDefinition(i int) IVsFilterDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVsFilterDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVsFilterDefinitionContext)
}

func (s *VsFilterListContext) AllKW_AND() []antlr.TerminalNode {
	return s.GetTokens(FSHParserKW_AND)
}

func (s *VsFilterListContext) KW_AND(i int) antlr.TerminalNode {
	return s.GetToken(FSHParserKW_AND, i)
}

func (s *VsFilterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsFilterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VsFilterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitVsFilterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) VsFilterList() (localctx IVsFilterListContext) {
	localctx = NewVsFilterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, FSHParserRULE_vsFilterList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(717)
		p.VsFilterDefinition()
	}
	p.SetState(722)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FSHParserKW_AND {
		{
			p.SetState(718)
			p.Match(FSHParserKW_AND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(719)
			p.VsFilterDefinition()
		}

		p.SetState(724)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVsFilterDefinitionContext is an interface to support dynamic dispatch.
type IVsFilterDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext
	VsFilterOperator() IVsFilterOperatorContext
	VsFilterValue() IVsFilterValueContext

	// IsVsFilterDefinitionContext differentiates from other interfaces.
	IsVsFilterDefinitionContext()
}

type VsFilterDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVsFilterDefinitionContext() *VsFilterDefinitionContext {
	var p = new(VsFilterDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_vsFilterDefinition
	return p
}

func InitEmptyVsFilterDefinitionContext(p *VsFilterDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_vsFilterDefinition
}

func (*VsFilterDefinitionContext) IsVsFilterDefinitionContext() {}

func NewVsFilterDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VsFilterDefinitionContext {
	var p = new(VsFilterDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_vsFilterDefinition

	return p
}

func (s *VsFilterDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *VsFilterDefinitionContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *VsFilterDefinitionContext) VsFilterOperator() IVsFilterOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVsFilterOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVsFilterOperatorContext)
}

func (s *VsFilterDefinitionContext) VsFilterValue() IVsFilterValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVsFilterValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVsFilterValueContext)
}

func (s *VsFilterDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsFilterDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VsFilterDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitVsFilterDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) VsFilterDefinition() (localctx IVsFilterDefinitionContext) {
	localctx = NewVsFilterDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, FSHParserRULE_vsFilterDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(725)
		p.Name()
	}
	{
		p.SetState(726)
		p.VsFilterOperator()
	}
	p.SetState(728)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-42)) & ^0x3f) == 0 && ((int64(1)<<(_la-42))&537985027) != 0 {
		{
			p.SetState(727)
			p.VsFilterValue()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVsFilterOperatorContext is an interface to support dynamic dispatch.
type IVsFilterOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUAL() antlr.TerminalNode
	SEQUENCE() antlr.TerminalNode

	// IsVsFilterOperatorContext differentiates from other interfaces.
	IsVsFilterOperatorContext()
}

type VsFilterOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVsFilterOperatorContext() *VsFilterOperatorContext {
	var p = new(VsFilterOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_vsFilterOperator
	return p
}

func InitEmptyVsFilterOperatorContext(p *VsFilterOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_vsFilterOperator
}

func (*VsFilterOperatorContext) IsVsFilterOperatorContext() {}

func NewVsFilterOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VsFilterOperatorContext {
	var p = new(VsFilterOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_vsFilterOperator

	return p
}

func (s *VsFilterOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *VsFilterOperatorContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(FSHParserEQUAL, 0)
}

func (s *VsFilterOperatorContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(FSHParserSEQUENCE, 0)
}

func (s *VsFilterOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsFilterOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VsFilterOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitVsFilterOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) VsFilterOperator() (localctx IVsFilterOperatorContext) {
	localctx = NewVsFilterOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, FSHParserRULE_vsFilterOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(730)
		_la = p.GetTokenStream().LA(1)

		if !(_la == FSHParserEQUAL || _la == FSHParserSEQUENCE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVsFilterValueContext is an interface to support dynamic dispatch.
type IVsFilterValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Code() ICodeContext
	KW_TRUE() antlr.TerminalNode
	KW_FALSE() antlr.TerminalNode
	REGEX() antlr.TerminalNode
	STRING() antlr.TerminalNode

	// IsVsFilterValueContext differentiates from other interfaces.
	IsVsFilterValueContext()
}

type VsFilterValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVsFilterValueContext() *VsFilterValueContext {
	var p = new(VsFilterValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_vsFilterValue
	return p
}

func InitEmptyVsFilterValueContext(p *VsFilterValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_vsFilterValue
}

func (*VsFilterValueContext) IsVsFilterValueContext() {}

func NewVsFilterValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VsFilterValueContext {
	var p = new(VsFilterValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_vsFilterValue

	return p
}

func (s *VsFilterValueContext) GetParser() antlr.Parser { return s.parser }

func (s *VsFilterValueContext) Code() ICodeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeContext)
}

func (s *VsFilterValueContext) KW_TRUE() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_TRUE, 0)
}

func (s *VsFilterValueContext) KW_FALSE() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_FALSE, 0)
}

func (s *VsFilterValueContext) REGEX() antlr.TerminalNode {
	return s.GetToken(FSHParserREGEX, 0)
}

func (s *VsFilterValueContext) STRING() antlr.TerminalNode {
	return s.GetToken(FSHParserSTRING, 0)
}

func (s *VsFilterValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsFilterValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VsFilterValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitVsFilterValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) VsFilterValue() (localctx IVsFilterValueContext) {
	localctx = NewVsFilterValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, FSHParserRULE_vsFilterValue)
	p.SetState(737)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FSHParserCODE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(732)
			p.Code()
		}

	case FSHParserKW_TRUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(733)
			p.Match(FSHParserKW_TRUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FSHParserKW_FALSE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(734)
			p.Match(FSHParserKW_FALSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FSHParserREGEX:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(735)
			p.Match(FSHParserREGEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FSHParserSTRING:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(736)
			p.Match(FSHParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INameContext is an interface to support dynamic dispatch.
type INameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEQUENCE() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	TIME() antlr.TerminalNode
	MostAlphaKeywords() IMostAlphaKeywordsContext

	// IsNameContext differentiates from other interfaces.
	IsNameContext()
}

type NameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameContext() *NameContext {
	var p = new(NameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_name
	return p
}

func InitEmptyNameContext(p *NameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_name
}

func (*NameContext) IsNameContext() {}

func NewNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameContext {
	var p = new(NameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_name

	return p
}

func (s *NameContext) GetParser() antlr.Parser { return s.parser }

func (s *NameContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(FSHParserSEQUENCE, 0)
}

func (s *NameContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(FSHParserNUMBER, 0)
}

func (s *NameContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(FSHParserDATETIME, 0)
}

func (s *NameContext) TIME() antlr.TerminalNode {
	return s.GetToken(FSHParserTIME, 0)
}

func (s *NameContext) MostAlphaKeywords() IMostAlphaKeywordsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMostAlphaKeywordsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMostAlphaKeywordsContext)
}

func (s *NameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Name() (localctx INameContext) {
	localctx = NewNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, FSHParserRULE_name)
	p.SetState(744)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FSHParserSEQUENCE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(739)
			p.Match(FSHParserSEQUENCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FSHParserNUMBER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(740)
			p.Match(FSHParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FSHParserDATETIME:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(741)
			p.Match(FSHParserDATETIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FSHParserTIME:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(742)
			p.Match(FSHParserTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FSHParserKW_MS, FSHParserKW_SU, FSHParserKW_TU, FSHParserKW_NORMATIVE, FSHParserKW_DRAFT, FSHParserKW_FROM, FSHParserKW_CONTAINS, FSHParserKW_NAMED, FSHParserKW_AND, FSHParserKW_ONLY, FSHParserKW_OR, FSHParserKW_OBEYS, FSHParserKW_TRUE, FSHParserKW_FALSE, FSHParserKW_INCLUDE, FSHParserKW_EXCLUDE, FSHParserKW_CODES, FSHParserKW_WHERE, FSHParserKW_VSREFERENCE, FSHParserKW_SYSTEM, FSHParserKW_CONTENTREFERENCE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(743)
			p.MostAlphaKeywords()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathContext is an interface to support dynamic dispatch.
type IPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEQUENCE() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	TIME() antlr.TerminalNode
	MostAlphaKeywords() IMostAlphaKeywordsContext

	// IsPathContext differentiates from other interfaces.
	IsPathContext()
}

type PathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathContext() *PathContext {
	var p = new(PathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_path
	return p
}

func InitEmptyPathContext(p *PathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_path
}

func (*PathContext) IsPathContext() {}

func NewPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathContext {
	var p = new(PathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_path

	return p
}

func (s *PathContext) GetParser() antlr.Parser { return s.parser }

func (s *PathContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(FSHParserSEQUENCE, 0)
}

func (s *PathContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(FSHParserNUMBER, 0)
}

func (s *PathContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(FSHParserDATETIME, 0)
}

func (s *PathContext) TIME() antlr.TerminalNode {
	return s.GetToken(FSHParserTIME, 0)
}

func (s *PathContext) MostAlphaKeywords() IMostAlphaKeywordsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMostAlphaKeywordsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMostAlphaKeywordsContext)
}

func (s *PathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitPath(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Path() (localctx IPathContext) {
	localctx = NewPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, FSHParserRULE_path)
	p.SetState(751)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FSHParserSEQUENCE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(746)
			p.Match(FSHParserSEQUENCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FSHParserNUMBER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(747)
			p.Match(FSHParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FSHParserDATETIME:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(748)
			p.Match(FSHParserDATETIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FSHParserTIME:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(749)
			p.Match(FSHParserTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FSHParserKW_MS, FSHParserKW_SU, FSHParserKW_TU, FSHParserKW_NORMATIVE, FSHParserKW_DRAFT, FSHParserKW_FROM, FSHParserKW_CONTAINS, FSHParserKW_NAMED, FSHParserKW_AND, FSHParserKW_ONLY, FSHParserKW_OR, FSHParserKW_OBEYS, FSHParserKW_TRUE, FSHParserKW_FALSE, FSHParserKW_INCLUDE, FSHParserKW_EXCLUDE, FSHParserKW_CODES, FSHParserKW_WHERE, FSHParserKW_VSREFERENCE, FSHParserKW_SYSTEM, FSHParserKW_CONTENTREFERENCE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(750)
			p.MostAlphaKeywords()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaretPathContext is an interface to support dynamic dispatch.
type ICaretPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CARET_SEQUENCE() antlr.TerminalNode

	// IsCaretPathContext differentiates from other interfaces.
	IsCaretPathContext()
}

type CaretPathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaretPathContext() *CaretPathContext {
	var p = new(CaretPathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_caretPath
	return p
}

func InitEmptyCaretPathContext(p *CaretPathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_caretPath
}

func (*CaretPathContext) IsCaretPathContext() {}

func NewCaretPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaretPathContext {
	var p = new(CaretPathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_caretPath

	return p
}

func (s *CaretPathContext) GetParser() antlr.Parser { return s.parser }

func (s *CaretPathContext) CARET_SEQUENCE() antlr.TerminalNode {
	return s.GetToken(FSHParserCARET_SEQUENCE, 0)
}

func (s *CaretPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaretPathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaretPathContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitCaretPath(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) CaretPath() (localctx ICaretPathContext) {
	localctx = NewCaretPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, FSHParserRULE_caretPath)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(753)
		p.Match(FSHParserCARET_SEQUENCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFlagContext is an interface to support dynamic dispatch.
type IFlagContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_MOD() antlr.TerminalNode
	KW_MS() antlr.TerminalNode
	KW_SU() antlr.TerminalNode
	KW_TU() antlr.TerminalNode
	KW_NORMATIVE() antlr.TerminalNode
	KW_DRAFT() antlr.TerminalNode

	// IsFlagContext differentiates from other interfaces.
	IsFlagContext()
}

type FlagContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlagContext() *FlagContext {
	var p = new(FlagContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_flag
	return p
}

func InitEmptyFlagContext(p *FlagContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_flag
}

func (*FlagContext) IsFlagContext() {}

func NewFlagContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FlagContext {
	var p = new(FlagContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_flag

	return p
}

func (s *FlagContext) GetParser() antlr.Parser { return s.parser }

func (s *FlagContext) KW_MOD() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_MOD, 0)
}

func (s *FlagContext) KW_MS() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_MS, 0)
}

func (s *FlagContext) KW_SU() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_SU, 0)
}

func (s *FlagContext) KW_TU() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_TU, 0)
}

func (s *FlagContext) KW_NORMATIVE() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_NORMATIVE, 0)
}

func (s *FlagContext) KW_DRAFT() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_DRAFT, 0)
}

func (s *FlagContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FlagContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FlagContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitFlag(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Flag() (localctx IFlagContext) {
	localctx = NewFlagContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, FSHParserRULE_flag)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(755)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2113929216) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStrengthContext is an interface to support dynamic dispatch.
type IStrengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_EXAMPLE() antlr.TerminalNode
	KW_PREFERRED() antlr.TerminalNode
	KW_EXTENSIBLE() antlr.TerminalNode
	KW_REQUIRED() antlr.TerminalNode

	// IsStrengthContext differentiates from other interfaces.
	IsStrengthContext()
}

type StrengthContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStrengthContext() *StrengthContext {
	var p = new(StrengthContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_strength
	return p
}

func InitEmptyStrengthContext(p *StrengthContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_strength
}

func (*StrengthContext) IsStrengthContext() {}

func NewStrengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StrengthContext {
	var p = new(StrengthContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_strength

	return p
}

func (s *StrengthContext) GetParser() antlr.Parser { return s.parser }

func (s *StrengthContext) KW_EXAMPLE() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_EXAMPLE, 0)
}

func (s *StrengthContext) KW_PREFERRED() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_PREFERRED, 0)
}

func (s *StrengthContext) KW_EXTENSIBLE() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_EXTENSIBLE, 0)
}

func (s *StrengthContext) KW_REQUIRED() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_REQUIRED, 0)
}

func (s *StrengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StrengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StrengthContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitStrength(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Strength() (localctx IStrengthContext) {
	localctx = NewStrengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, FSHParserRULE_strength)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(757)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&64424509440) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueContext is an interface to support dynamic dispatch.
type IValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING() antlr.TerminalNode
	MULTILINE_STRING() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	TIME() antlr.TerminalNode
	Reference() IReferenceContext
	Canonical() ICanonicalContext
	Code() ICodeContext
	Quantity() IQuantityContext
	Ratio() IRatioContext
	Bool_() IBoolContext
	Name() INameContext

	// IsValueContext differentiates from other interfaces.
	IsValueContext()
}

type ValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueContext() *ValueContext {
	var p = new(ValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_value
	return p
}

func InitEmptyValueContext(p *ValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_value
}

func (*ValueContext) IsValueContext() {}

func NewValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueContext {
	var p = new(ValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_value

	return p
}

func (s *ValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueContext) STRING() antlr.TerminalNode {
	return s.GetToken(FSHParserSTRING, 0)
}

func (s *ValueContext) MULTILINE_STRING() antlr.TerminalNode {
	return s.GetToken(FSHParserMULTILINE_STRING, 0)
}

func (s *ValueContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(FSHParserNUMBER, 0)
}

func (s *ValueContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(FSHParserDATETIME, 0)
}

func (s *ValueContext) TIME() antlr.TerminalNode {
	return s.GetToken(FSHParserTIME, 0)
}

func (s *ValueContext) Reference() IReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceContext)
}

func (s *ValueContext) Canonical() ICanonicalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICanonicalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICanonicalContext)
}

func (s *ValueContext) Code() ICodeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeContext)
}

func (s *ValueContext) Quantity() IQuantityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuantityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuantityContext)
}

func (s *ValueContext) Ratio() IRatioContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRatioContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRatioContext)
}

func (s *ValueContext) Bool_() IBoolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBoolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBoolContext)
}

func (s *ValueContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *ValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Value() (localctx IValueContext) {
	localctx = NewValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, FSHParserRULE_value)
	p.SetState(771)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(759)
			p.Match(FSHParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(760)
			p.Match(FSHParserMULTILINE_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(761)
			p.Match(FSHParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(762)
			p.Match(FSHParserDATETIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(763)
			p.Match(FSHParserTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(764)
			p.Reference()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(765)
			p.Canonical()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(766)
			p.Code()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(767)
			p.Quantity()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(768)
			p.Ratio()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(769)
			p.Bool_()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(770)
			p.Name()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IItemContext is an interface to support dynamic dispatch.
type IItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllName() []INameContext
	Name(i int) INameContext
	CARD() antlr.TerminalNode
	KW_NAMED() antlr.TerminalNode
	AllFlag() []IFlagContext
	Flag(i int) IFlagContext

	// IsItemContext differentiates from other interfaces.
	IsItemContext()
}

type ItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyItemContext() *ItemContext {
	var p = new(ItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_item
	return p
}

func InitEmptyItemContext(p *ItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_item
}

func (*ItemContext) IsItemContext() {}

func NewItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ItemContext {
	var p = new(ItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_item

	return p
}

func (s *ItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ItemContext) AllName() []INameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INameContext); ok {
			len++
		}
	}

	tst := make([]INameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INameContext); ok {
			tst[i] = t.(INameContext)
			i++
		}
	}

	return tst
}

func (s *ItemContext) Name(i int) INameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *ItemContext) CARD() antlr.TerminalNode {
	return s.GetToken(FSHParserCARD, 0)
}

func (s *ItemContext) KW_NAMED() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_NAMED, 0)
}

func (s *ItemContext) AllFlag() []IFlagContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFlagContext); ok {
			len++
		}
	}

	tst := make([]IFlagContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFlagContext); ok {
			tst[i] = t.(IFlagContext)
			i++
		}
	}

	return tst
}

func (s *ItemContext) Flag(i int) IFlagContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlagContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlagContext)
}

func (s *ItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Item() (localctx IItemContext) {
	localctx = NewItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, FSHParserRULE_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(773)
		p.Name()
	}
	p.SetState(776)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FSHParserKW_NAMED {
		{
			p.SetState(774)
			p.Match(FSHParserKW_NAMED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(775)
			p.Name()
		}

	}
	{
		p.SetState(778)
		p.Match(FSHParserCARD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(782)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2113929216) != 0 {
		{
			p.SetState(779)
			p.Flag()
		}

		p.SetState(784)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICodeContext is an interface to support dynamic dispatch.
type ICodeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CODE() antlr.TerminalNode
	STRING() antlr.TerminalNode

	// IsCodeContext differentiates from other interfaces.
	IsCodeContext()
}

type CodeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodeContext() *CodeContext {
	var p = new(CodeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_code
	return p
}

func InitEmptyCodeContext(p *CodeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_code
}

func (*CodeContext) IsCodeContext() {}

func NewCodeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodeContext {
	var p = new(CodeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_code

	return p
}

func (s *CodeContext) GetParser() antlr.Parser { return s.parser }

func (s *CodeContext) CODE() antlr.TerminalNode {
	return s.GetToken(FSHParserCODE, 0)
}

func (s *CodeContext) STRING() antlr.TerminalNode {
	return s.GetToken(FSHParserSTRING, 0)
}

func (s *CodeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitCode(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Code() (localctx ICodeContext) {
	localctx = NewCodeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, FSHParserRULE_code)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(785)
		p.Match(FSHParserCODE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(787)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FSHParserSTRING {
		{
			p.SetState(786)
			p.Match(FSHParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConceptContext is an interface to support dynamic dispatch.
type IConceptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	AllCODE() []antlr.TerminalNode
	CODE(i int) antlr.TerminalNode
	AllSTRING() []antlr.TerminalNode
	STRING(i int) antlr.TerminalNode
	MULTILINE_STRING() antlr.TerminalNode

	// IsConceptContext differentiates from other interfaces.
	IsConceptContext()
}

type ConceptContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConceptContext() *ConceptContext {
	var p = new(ConceptContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_concept
	return p
}

func InitEmptyConceptContext(p *ConceptContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_concept
}

func (*ConceptContext) IsConceptContext() {}

func NewConceptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConceptContext {
	var p = new(ConceptContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_concept

	return p
}

func (s *ConceptContext) GetParser() antlr.Parser { return s.parser }

func (s *ConceptContext) STAR() antlr.TerminalNode {
	return s.GetToken(FSHParserSTAR, 0)
}

func (s *ConceptContext) AllCODE() []antlr.TerminalNode {
	return s.GetTokens(FSHParserCODE)
}

func (s *ConceptContext) CODE(i int) antlr.TerminalNode {
	return s.GetToken(FSHParserCODE, i)
}

func (s *ConceptContext) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(FSHParserSTRING)
}

func (s *ConceptContext) STRING(i int) antlr.TerminalNode {
	return s.GetToken(FSHParserSTRING, i)
}

func (s *ConceptContext) MULTILINE_STRING() antlr.TerminalNode {
	return s.GetToken(FSHParserMULTILINE_STRING, 0)
}

func (s *ConceptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConceptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConceptContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitConcept(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Concept() (localctx IConceptContext) {
	localctx = NewConceptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, FSHParserRULE_concept)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(789)
		p.Match(FSHParserSTAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(791)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == FSHParserCODE {
		{
			p.SetState(790)
			p.Match(FSHParserCODE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(793)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(796)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 82, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(795)
			p.Match(FSHParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(799)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FSHParserSTRING || _la == FSHParserMULTILINE_STRING {
		{
			p.SetState(798)
			_la = p.GetTokenStream().LA(1)

			if !(_la == FSHParserSTRING || _la == FSHParserMULTILINE_STRING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuantityContext is an interface to support dynamic dispatch.
type IQuantityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNIT() antlr.TerminalNode
	CODE() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	STRING() antlr.TerminalNode

	// IsQuantityContext differentiates from other interfaces.
	IsQuantityContext()
}

type QuantityContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuantityContext() *QuantityContext {
	var p = new(QuantityContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_quantity
	return p
}

func InitEmptyQuantityContext(p *QuantityContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_quantity
}

func (*QuantityContext) IsQuantityContext() {}

func NewQuantityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuantityContext {
	var p = new(QuantityContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_quantity

	return p
}

func (s *QuantityContext) GetParser() antlr.Parser { return s.parser }

func (s *QuantityContext) UNIT() antlr.TerminalNode {
	return s.GetToken(FSHParserUNIT, 0)
}

func (s *QuantityContext) CODE() antlr.TerminalNode {
	return s.GetToken(FSHParserCODE, 0)
}

func (s *QuantityContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(FSHParserNUMBER, 0)
}

func (s *QuantityContext) STRING() antlr.TerminalNode {
	return s.GetToken(FSHParserSTRING, 0)
}

func (s *QuantityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuantityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuantityContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitQuantity(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Quantity() (localctx IQuantityContext) {
	localctx = NewQuantityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, FSHParserRULE_quantity)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(802)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FSHParserNUMBER {
		{
			p.SetState(801)
			p.Match(FSHParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(804)
		_la = p.GetTokenStream().LA(1)

		if !(_la == FSHParserUNIT || _la == FSHParserCODE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(806)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FSHParserSTRING {
		{
			p.SetState(805)
			p.Match(FSHParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRatioContext is an interface to support dynamic dispatch.
type IRatioContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRatioPart() []IRatioPartContext
	RatioPart(i int) IRatioPartContext
	COLON() antlr.TerminalNode

	// IsRatioContext differentiates from other interfaces.
	IsRatioContext()
}

type RatioContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRatioContext() *RatioContext {
	var p = new(RatioContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_ratio
	return p
}

func InitEmptyRatioContext(p *RatioContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_ratio
}

func (*RatioContext) IsRatioContext() {}

func NewRatioContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RatioContext {
	var p = new(RatioContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_ratio

	return p
}

func (s *RatioContext) GetParser() antlr.Parser { return s.parser }

func (s *RatioContext) AllRatioPart() []IRatioPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRatioPartContext); ok {
			len++
		}
	}

	tst := make([]IRatioPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRatioPartContext); ok {
			tst[i] = t.(IRatioPartContext)
			i++
		}
	}

	return tst
}

func (s *RatioContext) RatioPart(i int) IRatioPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRatioPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRatioPartContext)
}

func (s *RatioContext) COLON() antlr.TerminalNode {
	return s.GetToken(FSHParserCOLON, 0)
}

func (s *RatioContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RatioContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RatioContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitRatio(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Ratio() (localctx IRatioContext) {
	localctx = NewRatioContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, FSHParserRULE_ratio)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(808)
		p.RatioPart()
	}
	{
		p.SetState(809)
		p.Match(FSHParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(810)
		p.RatioPart()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReferenceContext is an interface to support dynamic dispatch.
type IReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REFERENCE() antlr.TerminalNode
	STRING() antlr.TerminalNode

	// IsReferenceContext differentiates from other interfaces.
	IsReferenceContext()
}

type ReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceContext() *ReferenceContext {
	var p = new(ReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_reference
	return p
}

func InitEmptyReferenceContext(p *ReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_reference
}

func (*ReferenceContext) IsReferenceContext() {}

func NewReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceContext {
	var p = new(ReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_reference

	return p
}

func (s *ReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(FSHParserREFERENCE, 0)
}

func (s *ReferenceContext) STRING() antlr.TerminalNode {
	return s.GetToken(FSHParserSTRING, 0)
}

func (s *ReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Reference() (localctx IReferenceContext) {
	localctx = NewReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, FSHParserRULE_reference)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(812)
		p.Match(FSHParserREFERENCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(814)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FSHParserSTRING {
		{
			p.SetState(813)
			p.Match(FSHParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReferenceTypeContext is an interface to support dynamic dispatch.
type IReferenceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REFERENCE() antlr.TerminalNode

	// IsReferenceTypeContext differentiates from other interfaces.
	IsReferenceTypeContext()
}

type ReferenceTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceTypeContext() *ReferenceTypeContext {
	var p = new(ReferenceTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_referenceType
	return p
}

func InitEmptyReferenceTypeContext(p *ReferenceTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_referenceType
}

func (*ReferenceTypeContext) IsReferenceTypeContext() {}

func NewReferenceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceTypeContext {
	var p = new(ReferenceTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_referenceType

	return p
}

func (s *ReferenceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceTypeContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(FSHParserREFERENCE, 0)
}

func (s *ReferenceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitReferenceType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) ReferenceType() (localctx IReferenceTypeContext) {
	localctx = NewReferenceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, FSHParserRULE_referenceType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(816)
		p.Match(FSHParserREFERENCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICodeableReferenceTypeContext is an interface to support dynamic dispatch.
type ICodeableReferenceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CODEABLE_REFERENCE() antlr.TerminalNode

	// IsCodeableReferenceTypeContext differentiates from other interfaces.
	IsCodeableReferenceTypeContext()
}

type CodeableReferenceTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodeableReferenceTypeContext() *CodeableReferenceTypeContext {
	var p = new(CodeableReferenceTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_codeableReferenceType
	return p
}

func InitEmptyCodeableReferenceTypeContext(p *CodeableReferenceTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_codeableReferenceType
}

func (*CodeableReferenceTypeContext) IsCodeableReferenceTypeContext() {}

func NewCodeableReferenceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodeableReferenceTypeContext {
	var p = new(CodeableReferenceTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_codeableReferenceType

	return p
}

func (s *CodeableReferenceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *CodeableReferenceTypeContext) CODEABLE_REFERENCE() antlr.TerminalNode {
	return s.GetToken(FSHParserCODEABLE_REFERENCE, 0)
}

func (s *CodeableReferenceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeableReferenceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodeableReferenceTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitCodeableReferenceType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) CodeableReferenceType() (localctx ICodeableReferenceTypeContext) {
	localctx = NewCodeableReferenceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, FSHParserRULE_codeableReferenceType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(818)
		p.Match(FSHParserCODEABLE_REFERENCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICanonicalContext is an interface to support dynamic dispatch.
type ICanonicalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANONICAL() antlr.TerminalNode

	// IsCanonicalContext differentiates from other interfaces.
	IsCanonicalContext()
}

type CanonicalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCanonicalContext() *CanonicalContext {
	var p = new(CanonicalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_canonical
	return p
}

func InitEmptyCanonicalContext(p *CanonicalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_canonical
}

func (*CanonicalContext) IsCanonicalContext() {}

func NewCanonicalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CanonicalContext {
	var p = new(CanonicalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_canonical

	return p
}

func (s *CanonicalContext) GetParser() antlr.Parser { return s.parser }

func (s *CanonicalContext) CANONICAL() antlr.TerminalNode {
	return s.GetToken(FSHParserCANONICAL, 0)
}

func (s *CanonicalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CanonicalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CanonicalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitCanonical(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Canonical() (localctx ICanonicalContext) {
	localctx = NewCanonicalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, FSHParserRULE_canonical)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(820)
		p.Match(FSHParserCANONICAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRatioPartContext is an interface to support dynamic dispatch.
type IRatioPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NUMBER() antlr.TerminalNode
	Quantity() IQuantityContext

	// IsRatioPartContext differentiates from other interfaces.
	IsRatioPartContext()
}

type RatioPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRatioPartContext() *RatioPartContext {
	var p = new(RatioPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_ratioPart
	return p
}

func InitEmptyRatioPartContext(p *RatioPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_ratioPart
}

func (*RatioPartContext) IsRatioPartContext() {}

func NewRatioPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RatioPartContext {
	var p = new(RatioPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_ratioPart

	return p
}

func (s *RatioPartContext) GetParser() antlr.Parser { return s.parser }

func (s *RatioPartContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(FSHParserNUMBER, 0)
}

func (s *RatioPartContext) Quantity() IQuantityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuantityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuantityContext)
}

func (s *RatioPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RatioPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RatioPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitRatioPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) RatioPart() (localctx IRatioPartContext) {
	localctx = NewRatioPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, FSHParserRULE_ratioPart)
	p.SetState(824)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(822)
			p.Match(FSHParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(823)
			p.Quantity()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBoolContext is an interface to support dynamic dispatch.
type IBoolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_TRUE() antlr.TerminalNode
	KW_FALSE() antlr.TerminalNode

	// IsBoolContext differentiates from other interfaces.
	IsBoolContext()
}

type BoolContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBoolContext() *BoolContext {
	var p = new(BoolContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_bool
	return p
}

func InitEmptyBoolContext(p *BoolContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_bool
}

func (*BoolContext) IsBoolContext() {}

func NewBoolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BoolContext {
	var p = new(BoolContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_bool

	return p
}

func (s *BoolContext) GetParser() antlr.Parser { return s.parser }

func (s *BoolContext) KW_TRUE() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_TRUE, 0)
}

func (s *BoolContext) KW_FALSE() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_FALSE, 0)
}

func (s *BoolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BoolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BoolContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitBool(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) Bool_() (localctx IBoolContext) {
	localctx = NewBoolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, FSHParserRULE_bool)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(826)
		_la = p.GetTokenStream().LA(1)

		if !(_la == FSHParserKW_TRUE || _la == FSHParserKW_FALSE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetTypeContext is an interface to support dynamic dispatch.
type ITargetTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext
	ReferenceType() IReferenceTypeContext
	Canonical() ICanonicalContext
	CodeableReferenceType() ICodeableReferenceTypeContext

	// IsTargetTypeContext differentiates from other interfaces.
	IsTargetTypeContext()
}

type TargetTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetTypeContext() *TargetTypeContext {
	var p = new(TargetTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_targetType
	return p
}

func InitEmptyTargetTypeContext(p *TargetTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_targetType
}

func (*TargetTypeContext) IsTargetTypeContext() {}

func NewTargetTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetTypeContext {
	var p = new(TargetTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_targetType

	return p
}

func (s *TargetTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetTypeContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *TargetTypeContext) ReferenceType() IReferenceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceTypeContext)
}

func (s *TargetTypeContext) Canonical() ICanonicalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICanonicalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICanonicalContext)
}

func (s *TargetTypeContext) CodeableReferenceType() ICodeableReferenceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeableReferenceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeableReferenceTypeContext)
}

func (s *TargetTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TargetTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitTargetType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) TargetType() (localctx ITargetTypeContext) {
	localctx = NewTargetTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, FSHParserRULE_targetType)
	p.SetState(832)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FSHParserKW_MS, FSHParserKW_SU, FSHParserKW_TU, FSHParserKW_NORMATIVE, FSHParserKW_DRAFT, FSHParserKW_FROM, FSHParserKW_CONTAINS, FSHParserKW_NAMED, FSHParserKW_AND, FSHParserKW_ONLY, FSHParserKW_OR, FSHParserKW_OBEYS, FSHParserKW_TRUE, FSHParserKW_FALSE, FSHParserKW_INCLUDE, FSHParserKW_EXCLUDE, FSHParserKW_CODES, FSHParserKW_WHERE, FSHParserKW_VSREFERENCE, FSHParserKW_SYSTEM, FSHParserKW_CONTENTREFERENCE, FSHParserNUMBER, FSHParserDATETIME, FSHParserTIME, FSHParserSEQUENCE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(828)
			p.Name()
		}

	case FSHParserREFERENCE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(829)
			p.ReferenceType()
		}

	case FSHParserCANONICAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(830)
			p.Canonical()
		}

	case FSHParserCODEABLE_REFERENCE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(831)
			p.CodeableReferenceType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMostAlphaKeywordsContext is an interface to support dynamic dispatch.
type IMostAlphaKeywordsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KW_MS() antlr.TerminalNode
	KW_SU() antlr.TerminalNode
	KW_TU() antlr.TerminalNode
	KW_NORMATIVE() antlr.TerminalNode
	KW_DRAFT() antlr.TerminalNode
	KW_FROM() antlr.TerminalNode
	KW_CONTAINS() antlr.TerminalNode
	KW_NAMED() antlr.TerminalNode
	KW_AND() antlr.TerminalNode
	KW_ONLY() antlr.TerminalNode
	KW_OR() antlr.TerminalNode
	KW_OBEYS() antlr.TerminalNode
	KW_TRUE() antlr.TerminalNode
	KW_FALSE() antlr.TerminalNode
	KW_INCLUDE() antlr.TerminalNode
	KW_EXCLUDE() antlr.TerminalNode
	KW_CODES() antlr.TerminalNode
	KW_WHERE() antlr.TerminalNode
	KW_VSREFERENCE() antlr.TerminalNode
	KW_SYSTEM() antlr.TerminalNode
	KW_CONTENTREFERENCE() antlr.TerminalNode

	// IsMostAlphaKeywordsContext differentiates from other interfaces.
	IsMostAlphaKeywordsContext()
}

type MostAlphaKeywordsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMostAlphaKeywordsContext() *MostAlphaKeywordsContext {
	var p = new(MostAlphaKeywordsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_mostAlphaKeywords
	return p
}

func InitEmptyMostAlphaKeywordsContext(p *MostAlphaKeywordsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FSHParserRULE_mostAlphaKeywords
}

func (*MostAlphaKeywordsContext) IsMostAlphaKeywordsContext() {}

func NewMostAlphaKeywordsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MostAlphaKeywordsContext {
	var p = new(MostAlphaKeywordsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FSHParserRULE_mostAlphaKeywords

	return p
}

func (s *MostAlphaKeywordsContext) GetParser() antlr.Parser { return s.parser }

func (s *MostAlphaKeywordsContext) KW_MS() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_MS, 0)
}

func (s *MostAlphaKeywordsContext) KW_SU() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_SU, 0)
}

func (s *MostAlphaKeywordsContext) KW_TU() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_TU, 0)
}

func (s *MostAlphaKeywordsContext) KW_NORMATIVE() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_NORMATIVE, 0)
}

func (s *MostAlphaKeywordsContext) KW_DRAFT() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_DRAFT, 0)
}

func (s *MostAlphaKeywordsContext) KW_FROM() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_FROM, 0)
}

func (s *MostAlphaKeywordsContext) KW_CONTAINS() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_CONTAINS, 0)
}

func (s *MostAlphaKeywordsContext) KW_NAMED() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_NAMED, 0)
}

func (s *MostAlphaKeywordsContext) KW_AND() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_AND, 0)
}

func (s *MostAlphaKeywordsContext) KW_ONLY() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_ONLY, 0)
}

func (s *MostAlphaKeywordsContext) KW_OR() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_OR, 0)
}

func (s *MostAlphaKeywordsContext) KW_OBEYS() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_OBEYS, 0)
}

func (s *MostAlphaKeywordsContext) KW_TRUE() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_TRUE, 0)
}

func (s *MostAlphaKeywordsContext) KW_FALSE() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_FALSE, 0)
}

func (s *MostAlphaKeywordsContext) KW_INCLUDE() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_INCLUDE, 0)
}

func (s *MostAlphaKeywordsContext) KW_EXCLUDE() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_EXCLUDE, 0)
}

func (s *MostAlphaKeywordsContext) KW_CODES() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_CODES, 0)
}

func (s *MostAlphaKeywordsContext) KW_WHERE() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_WHERE, 0)
}

func (s *MostAlphaKeywordsContext) KW_VSREFERENCE() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_VSREFERENCE, 0)
}

func (s *MostAlphaKeywordsContext) KW_SYSTEM() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_SYSTEM, 0)
}

func (s *MostAlphaKeywordsContext) KW_CONTENTREFERENCE() antlr.TerminalNode {
	return s.GetToken(FSHParserKW_CONTENTREFERENCE, 0)
}

func (s *MostAlphaKeywordsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MostAlphaKeywordsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MostAlphaKeywordsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FSHVisitor:
		return t.VisitMostAlphaKeywords(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FSHParser) MostAlphaKeywords() (localctx IMostAlphaKeywordsContext) {
	localctx = NewMostAlphaKeywordsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, FSHParserRULE_mostAlphaKeywords)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(834)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&5629435042594816) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}
