package parser

import (
	"errors"
	"fmt"
	"strconv"
	"strings"

	"github.com/verily-src/fsh-lint/internal/fsh/internal/grammar"
	"github.com/verily-src/fsh-lint/internal/fsh/types"

	"github.com/antlr4-go/antlr/v4"
)

var (
	ErrUnexpectedMetadataType                = errors.New("unexpected metadata type")
	ErrCodeSystemConceptWithInvalidHierarchy = errors.New("invalid hierarchy in codesystem concept")
)

// FSHVisitor is a visitor for the FSH grammar.
// The skeleton is generated by the ANTLR tool, as a stub implementation of the fsh_visitor interface.
type FSHVisitor struct {
	*antlr.BaseParseTreeVisitor
}

func (v *FSHVisitor) Visit(tree antlr.ParseTree) any {
	return tree.Accept(v)
}

func (v *FSHVisitor) VisitDoc(ctx grammar.IDocContext) (*types.FSHDocument, error) {
	doc := &types.FSHDocument{}
	for _, entry := range ctx.AllEntity() {
		if entry.Alias() != nil {
			entry.Alias().Accept(v)
		}
		if entry.Profile() != nil {
			p, err := v.VisitProfile(entry.Profile())
			if err != nil {
				return nil, err
			}
			doc.Profiles = append(doc.Profiles, p)
		}
		if entry.Extension() != nil {
			e, err := v.VisitExtension(entry.Extension())
			if err != nil {
				return nil, err
			}
			doc.Extensions = append(doc.Extensions, e)
		}
		if entry.Logical() != nil {
			entry.Logical().Accept(v)
		}
		if entry.Resource() != nil {
			entry.Resource().Accept(v)
		}
		if entry.Instance() != nil {
			i, err := v.VisitInstance(entry.Instance())
			if err != nil {
				return nil, err
			}
			doc.Instances = append(doc.Instances, i)
		}
		if entry.Invariant() != nil {
			entry.Invariant().Accept(v)
		}
		if entry.ValueSet() != nil {
			vs, err := v.VisitValueSet(entry.ValueSet())
			if err != nil {
				return nil, err
			}
			doc.ValueSets = append(doc.ValueSets, vs)
		}
		if entry.CodeSystem() != nil {
			cs, err := v.VisitCodeSystem(entry.CodeSystem())
			if err != nil {
				return nil, err
			}
			doc.CodeSystems = append(doc.CodeSystems, cs)
		}
		if entry.RuleSet() != nil {
			entry.RuleSet().Accept(v)
		}
		if entry.ParamRuleSet() != nil {
			entry.ParamRuleSet().Accept(v)
		}
		if entry.Mapping() != nil {
			entry.Mapping().Accept(v)
		}
	}
	return doc, nil
}

func (v *FSHVisitor) VisitEntity(ctx grammar.IEntityContext) interface{} {
	return v.VisitChildren(ctx)
}

func (v *FSHVisitor) VisitAlias(ctx grammar.IAliasContext) interface{} {
	return v.VisitChildren(ctx)
}

func (v *FSHVisitor) VisitProfile(ctx grammar.IProfileContext) (*types.Profile, error) {
	p := &types.Profile{}
	p.Name = v.VisitName(ctx.Name())

	for _, md := range ctx.AllSdMetadata() {
		kv := v.VisitSDMetadata(md)
		switch kv.key {
		case "parent":
			p.Parent = kv.value
		case "id":
			p.ID = kv.value
		case "title":
			p.Title = kv.value
		case "description":
			p.Description = kv.value
		default:
			return nil, fmt.Errorf("%w, got %s", ErrUnexpectedMetadataType, kv.key)
		}
	}

	rules := &types.StructureDefRules{}
	for _, rule := range ctx.AllSdRule() {
		v.VisitSDRule(rule, rules)
	}

	p.ProfileRules = rules
	return p, nil
}

func (v *FSHVisitor) VisitExtension(ctx grammar.IExtensionContext) (*types.Extension, error) {
	e := &types.Extension{}
	e.Name = v.VisitName(ctx.Name())

	for _, md := range ctx.AllSdMetadata() {
		kv := v.VisitSDMetadata(md)
		switch kv.key {
		case "parent":
			e.Parent = kv.value
		case "id":
			e.ID = kv.value
		case "title":
			e.Title = kv.value
		case "description":
			e.Description = kv.value
		default:
			return nil, fmt.Errorf("%w, got %s", ErrUnexpectedMetadataType, kv.key)
		}
	}

	rules := &types.StructureDefRules{}
	for _, rule := range ctx.AllSdRule() {
		v.VisitSDRule(rule, rules)
	}
	e.ExtensionRules = rules

	var contexts []*types.ParsedElement[string]
	for _, context := range ctx.AllContext() {
		v.VisitContext(context, &contexts)
	}
	e.Contexts = contexts

	return e, nil
}

func (v *FSHVisitor) VisitLogical(ctx grammar.ILogicalContext) interface{} {
	return v.VisitChildren(ctx)
}

func (v *FSHVisitor) VisitResource(ctx grammar.IResourceContext) interface{} {
	return v.VisitChildren(ctx)
}

func (v *FSHVisitor) VisitSDMetadata(ctx grammar.ISdMetadataContext) *keyValue {
	kv := &keyValue{}
	if ctx.Parent() != nil {
		p := v.VisitParent(ctx.Parent())
		kv = &keyValue{"parent", p}
	} else if ctx.Id() != nil {
		id := v.VisitId(ctx.Id())
		kv = &keyValue{"id", id}
	} else if ctx.Title() != nil {
		t := v.VisitTitle(ctx.Title())
		kv = &keyValue{"title", t}
	} else if ctx.Description() != nil {
		d := v.VisitDescription(ctx.Description())
		kv = &keyValue{"description", d}
	}
	return kv
}

// VisitSDRule modifies rules by appending one rule to the appropriate rule type list. For more information on all possible profile rules,
// see https://build.fhir.org/ig/HL7/fhir-shorthand/reference.html#defining-profiles:~:text=Rules%20types%20that%20apply%20to%20Profiles
func (v *FSHVisitor) VisitSDRule(ctx grammar.ISdRuleContext, rules *types.StructureDefRules) {
	if ctx.CardRule() != nil {
		c := v.VisitCardRule(ctx.CardRule())
		rules.CardRules = append(rules.CardRules, c)
	} else if ctx.FlagRule() != nil {
		f := v.VisitFlagRule(ctx.FlagRule())
		rules.FlagRules = append(rules.FlagRules, f)
	} else if ctx.ValueSetRule() != nil {
		vs := v.VisitValueSetRule(ctx.ValueSetRule())
		rules.BindingRules = append(rules.BindingRules, vs)
	} else if ctx.FixedValueRule() != nil {
		f := v.VisitFixedValueRule(ctx.FixedValueRule())
		rules.AssignmentRules = append(rules.AssignmentRules, f)
	} else if ctx.ContainsRule() != nil {
		c := v.VisitContainsRule(ctx.ContainsRule())
		rules.ContainsRules = append(rules.ContainsRules, c)
	} else if ctx.OnlyRule() != nil {
		o := v.VisitOnlyRule(ctx.OnlyRule())
		rules.TypeRules = append(rules.TypeRules, o)
	} else if ctx.ObeysRule() != nil {
		o := v.VisitObeysRule(ctx.ObeysRule())
		rules.ObeysRules = append(rules.ObeysRules, o)
	} else if ctx.CaretValueRule() != nil {
		c := v.VisitCaretValueRule(ctx.CaretValueRule())
		rules.CaretValueRules = append(rules.CaretValueRules, c)
	} else if ctx.InsertRule() != nil {
		i := v.VisitInsertRule(ctx.InsertRule())
		rules.InsertRules = append(rules.InsertRules, i)
	} else if ctx.PathRule() != nil {
		p := v.VisitPathRule(ctx.PathRule())
		rules.PathRules = append(rules.PathRules, p)
	}
}

func (v *FSHVisitor) VisitLrRule(ctx grammar.ILrRuleContext) interface{} {
	return v.VisitChildren(ctx)
}

func (v *FSHVisitor) VisitInstance(ctx grammar.IInstanceContext) (*types.Instance, error) {
	i := &types.Instance{}
	i.Name = v.VisitName(ctx.Name())

	for _, md := range ctx.AllInstanceMetadata() {
		kv := v.VisitInstanceMetadata(md)
		switch kv.key {
		case "instanceOf":
			i.InstanceOf = kv.value
		case "title":
			i.Title = kv.value
		case "description":
			i.Description = kv.value
		case "usage":
			i.Usage = kv.value
		default:
			return nil, fmt.Errorf("%w, got %s", ErrUnexpectedMetadataType, kv.key)
		}
	}

	rules := &types.InstanceRules{}
	for _, rule := range ctx.AllInstanceRule() {
		v.VisitInstanceRule(rule, rules)
	}

	i.InstanceRules = rules

	return i, nil
}

func (v *FSHVisitor) VisitInstanceMetadata(ctx grammar.IInstanceMetadataContext) *keyValue {
	kv := &keyValue{}
	if ctx.InstanceOf() != nil {
		io := v.VisitInstanceOf(ctx.InstanceOf())
		kv = &keyValue{"instanceOf", io}
	} else if ctx.Title() != nil {
		t := v.VisitTitle(ctx.Title())
		kv = &keyValue{"title", t}
	} else if ctx.Description() != nil {
		d := v.VisitDescription(ctx.Description())
		kv = &keyValue{"description", d}
	} else if ctx.Usage() != nil {
		u := v.VisitUsage(ctx.Usage())
		kv = &keyValue{"usage", u}
	}
	return kv
}

func (v *FSHVisitor) VisitInstanceRule(ctx grammar.IInstanceRuleContext, rules *types.InstanceRules) {
	if ctx.FixedValueRule() != nil {
		f := v.VisitFixedValueRule(ctx.FixedValueRule())
		rules.AssignmentRules = append(rules.AssignmentRules, f)
	} else if ctx.InsertRule() != nil {
		i := v.VisitInsertRule(ctx.InsertRule())
		rules.InsertRules = append(rules.InsertRules, i)
	} else if ctx.PathRule() != nil {
		p := v.VisitPathRule(ctx.PathRule())
		rules.PathRules = append(rules.PathRules, p)
	}
}

func (v *FSHVisitor) VisitInvariant(ctx grammar.IInvariantContext) interface{} {
	return v.VisitChildren(ctx)
}

func (v *FSHVisitor) VisitInvariantMetadata(ctx grammar.IInvariantMetadataContext) interface{} {
	return v.VisitChildren(ctx)
}

func (v *FSHVisitor) VisitInvariantRule(ctx grammar.IInvariantRuleContext) interface{} {
	return v.VisitChildren(ctx)
}

func (v *FSHVisitor) VisitValueSet(ctx grammar.IValueSetContext) (*types.ValueSet, error) {
	vs := &types.ValueSet{}
	vs.Name = v.VisitName(ctx.Name())
	for _, md := range ctx.AllVsMetadata() {
		kv := v.VisitVSMetadata(md)
		switch kv.key {
		case "id":
			vs.ID = kv.value
		case "title":
			vs.Title = kv.value
		case "description":
			vs.Description = kv.value
		default:
			return nil, fmt.Errorf("%w, got %s", ErrUnexpectedMetadataType, kv.key)
		}
	}

	vs.IncludeComponents = make([]*types.ValueSetComponent, 0)
	vs.ExcludeComponents = make([]*types.ValueSetComponent, 0)
	vs.ValueSetRules = &types.ValueSetRules{}
	for _, rule := range ctx.AllVsRule() {
		v.VisitVSRule(rule, vs)
	}

	return vs, nil
}

func (v *FSHVisitor) VisitVSMetadata(ctx grammar.IVsMetadataContext) *keyValue {
	kv := &keyValue{}
	if ctx.Id() != nil {
		id := v.VisitId(ctx.Id())
		kv = &keyValue{"id", id}
	} else if ctx.Title() != nil {
		t := v.VisitTitle(ctx.Title())
		kv = &keyValue{"title", t}
	} else if ctx.Description() != nil {
		d := v.VisitDescription(ctx.Description())
		kv = &keyValue{"description", d}
	}
	return kv
}

// VisitVSRule modifies rules by appending one rule to the appropriate rule type list, or appending to the list of either
// IncludeComponents, or ExcludeComponents. For more information on all possible value set rules, see
// https://build.fhir.org/ig/HL7/fhir-shorthand/reference.html#defining-value-sets:~:text=Rule%20types%20that%20apply%20to%20ValueSets
func (v *FSHVisitor) VisitVSRule(ctx grammar.IVsRuleContext, vs *types.ValueSet) {
	if ctx.VsComponent() != nil {
		v.VisitVSComponent(ctx.VsComponent(), &vs.IncludeComponents, &vs.ExcludeComponents)
	} else if ctx.CaretValueRule() != nil {
		c := v.VisitCaretValueRule(ctx.CaretValueRule())
		vs.ValueSetRules.CaretValueRules = append(vs.ValueSetRules.CaretValueRules, c)
	} else if ctx.CodeCaretValueRule() != nil {
		c := v.VisitCodeCaretValueRule(ctx.CodeCaretValueRule())
		vs.ValueSetRules.CodeCaretValueRules = append(vs.ValueSetRules.CodeCaretValueRules, c)
	} else if ctx.InsertRule() != nil {
		i := v.VisitInsertRule(ctx.InsertRule())
		vs.ValueSetRules.InsertRules = append(vs.ValueSetRules.InsertRules, i)
	} else if ctx.CodeInsertRule() != nil {
		c := v.VisitCodeInsertRule(ctx.CodeInsertRule())
		vs.ValueSetRules.CodeInsertRules = append(vs.ValueSetRules.CodeInsertRules, c)
	}
}

func (v *FSHVisitor) VisitCodeSystem(ctx grammar.ICodeSystemContext) (*types.CodeSystem, error) {
	cs := &types.CodeSystem{}
	cs.Name = v.VisitName(ctx.Name())
	for _, md := range ctx.AllCsMetadata() {
		kv := v.VisitCSMetadata(md)
		switch kv.key {
		case "id":
			cs.ID = kv.value
		case "title":
			cs.Title = kv.value
		case "description":
			cs.Description = kv.value
		default:
			return nil, fmt.Errorf("%w, got %s", ErrUnexpectedMetadataType, kv.key)
		}
	}

	concepts := make([]*types.Concept, 0)

	for _, rule := range ctx.AllCsRule() {

		// For rule: someRule, the ancestors will be [ancestor1, ancestor2, ...]
		// where ancestor1 is the parent of ancestor2, and so on.
		concept, ancestors := v.VisitCSRule(rule)

		if concept == nil { // rule is not a concept
			continue
		}

		// start at the top ancestorLevel, the parentless concepts
		ancestorLevel := &concepts

		// if there are no ancestors, just add the concept to the top level
		if ancestors == nil {
			*ancestorLevel = append(*ancestorLevel, concept)

			continue
		}

		// for each level of ancestor, going down from the top level
		for _, nextAncestor := range ancestors {
			found := false

			// look for the ancestor we want in the exisiting concepts
			for _, parent := range *ancestorLevel {
				if parent.Name.Value == nextAncestor {
					ancestorLevel = &parent.SubConcepts
					found = true
				}
			}

			if !found {
				// couldn't find the next ancestor in the path
				return nil, fmt.Errorf("%w, got %s", ErrCodeSystemConceptWithInvalidHierarchy, nextAncestor)
			}
		}

		// now ancestorLevel is at the level we want to insert concept at
		*ancestorLevel = append(*ancestorLevel, concept)
	}

	cs.Concepts = concepts
	return cs, nil
}

func (v *FSHVisitor) VisitCSMetadata(ctx grammar.ICsMetadataContext) *keyValue {
	kv := &keyValue{}
	if ctx.Id() != nil {
		id := v.VisitId(ctx.Id())
		kv = &keyValue{"id", id}
	} else if ctx.Title() != nil {
		t := v.VisitTitle(ctx.Title())
		kv = &keyValue{"title", t}
	} else if ctx.Description() != nil {
		d := v.VisitDescription(ctx.Description())
		kv = &keyValue{"description", d}
	}
	return kv
}

func (v *FSHVisitor) VisitCSRule(ctx grammar.ICsRuleContext) (*types.Concept, []string) {
	if ctx.Concept() != nil {
		return v.VisitConcept(ctx.Concept())
	} else {
		return nil, nil
	}
}

func (v *FSHVisitor) VisitRuleSet(ctx grammar.IRuleSetContext) interface{} {
	return v.VisitChildren(ctx)
}

func (v *FSHVisitor) VisitRuleSetRule(ctx grammar.IRuleSetRuleContext) interface{} {
	return v.VisitChildren(ctx)
}

func (v *FSHVisitor) VisitParamRuleSet(ctx grammar.IParamRuleSetContext) interface{} {
	return v.VisitChildren(ctx)
}

func (v *FSHVisitor) VisitParamRuleSetRef(ctx grammar.IParamRuleSetRefContext, ruleSetName **types.ParsedElement[string], parameters *[]*types.ParsedElement[string]) {
	if ctx.PARAM_RULESET_REFERENCE() != nil {
		name := ctx.PARAM_RULESET_REFERENCE().GetText()
		trimmedName := strings.TrimSuffix(name, "(")
		trimmedName = strings.TrimSpace(trimmedName)
		*ruleSetName = createParsedElement(trimmedName, ctx)
	}

	for _, param := range ctx.AllParameter() {
		*parameters = append(*parameters, v.VisitParameter(param))
	}

	if ctx.LastParameter() != nil {
		*parameters = append(*parameters, v.VisitLastParameter(ctx.LastParameter()))
	}
}

func (v *FSHVisitor) VisitParameter(ctx grammar.IParameterContext) *types.ParsedElement[string] {
	s := ctx.GetText()
	s = strings.Trim(s, ", ")
	s = trimQuotes(s)

	return createParsedElement(s, ctx)
}

func (v *FSHVisitor) VisitLastParameter(ctx grammar.ILastParameterContext) *types.ParsedElement[string] {
	s := ctx.GetText()
	s = strings.Trim(s, ") ")
	s = trimQuotes(s)

	return createParsedElement(s, ctx)
}

func (v *FSHVisitor) VisitParamRuleSetContent(ctx grammar.IParamRuleSetContentContext) interface{} {
	return v.VisitChildren(ctx)
}

func (v *FSHVisitor) VisitMapping(ctx grammar.IMappingContext) interface{} {
	return v.VisitChildren(ctx)
}

func (v *FSHVisitor) VisitMappingMetadata(ctx grammar.IMappingMetadataContext) interface{} {
	return v.VisitChildren(ctx)
}

func (v *FSHVisitor) VisitMappingEntityRule(ctx grammar.IMappingEntityRuleContext) interface{} {
	return v.VisitChildren(ctx)
}

// VisitParent returns the name of the parent of the entity.
// The parser sometimes returns the text enclosed with double quotes, so trimming that off
// to be consistent with the rest of the fields.
func (v *FSHVisitor) VisitParent(ctx grammar.IParentContext) *types.ParsedElement[string] {
	s := ctx.Name().GetText()
	s = trimQuotes(s)

	return createParsedElement(s, ctx)
}

func (v *FSHVisitor) VisitId(ctx grammar.IIdContext) *types.ParsedElement[string] {
	return v.VisitName(ctx.Name())
}

// VisitName returns the name of the entity.
// The parser sometimes returns the text enclosed with double quotes, so trimming that off
// to be consistent with the rest of the fields.
func (v *FSHVisitor) VisitTitle(ctx grammar.ITitleContext) *types.ParsedElement[string] {
	s := ctx.STRING().GetText()
	s = trimQuotes(s)

	return createParsedElement(s, ctx)
}

// VisitDescription returns the description of the entity.
// The parser sometimes returns the text enclosed with double quotes, so trimming that off
// to be consistent with the rest of the fields.
func (v *FSHVisitor) VisitDescription(ctx grammar.IDescriptionContext) *types.ParsedElement[string] {
	s := ""
	if ctx.MULTILINE_STRING() != nil {
		s = ctx.MULTILINE_STRING().GetText()
	} else {
		s = ctx.STRING().GetText()
	}
	s = trimQuotes(s)

	return createParsedElement(s, ctx)
}

func (v *FSHVisitor) VisitExpression(ctx grammar.IExpressionContext) interface{} {
	return v.VisitChildren(ctx)
}

func (v *FSHVisitor) VisitXpath(ctx grammar.IXpathContext) interface{} {
	return v.VisitChildren(ctx)
}

func (v *FSHVisitor) VisitSeverity(ctx grammar.ISeverityContext) interface{} {
	return v.VisitChildren(ctx)
}

func (v *FSHVisitor) VisitInstanceOf(ctx grammar.IInstanceOfContext) *types.ParsedElement[string] {
	if ctx.Name() != nil {
		return v.VisitName(ctx.Name())
	}
	return createParsedElement("", ctx)
}

func (v *FSHVisitor) VisitUsage(ctx grammar.IUsageContext) *types.ParsedElement[string] {
	return createParsedElement(ctx.CODE().GetText(), ctx)
}

func (v *FSHVisitor) VisitSource(ctx grammar.ISourceContext) interface{} {
	return v.VisitChildren(ctx)
}

func (v *FSHVisitor) VisitTarget(ctx grammar.ITargetContext) interface{} {
	return v.VisitChildren(ctx)
}

// VisitContext modifies contexts by appending all context items. For more information on the context keyword,
// see https://build.fhir.org/ig/HL7/fhir-shorthand/reference.html#defining-extensions
func (v *FSHVisitor) VisitContext(ctx grammar.IContextContext, contexts *[]*types.ParsedElement[string]) {
	for _, item := range ctx.AllContextItem() {
		*contexts = append(*contexts, v.VisitContextItem(item))
	}

	if ctx.LastContextItem() != nil {
		*contexts = append(*contexts, v.VisitLastContextItem(ctx.LastContextItem()))
	}
}

func (v *FSHVisitor) VisitContextItem(ctx grammar.IContextItemContext) *types.ParsedElement[string] {
	item := ""

	if ctx.QUOTED_CONTEXT() != nil {
		item = ctx.QUOTED_CONTEXT().GetText()
	} else if ctx.UNQUOTED_CONTEXT() != nil {
		item = ctx.UNQUOTED_CONTEXT().GetText()
	}

	item = strings.Trim(item, ", ")
	item = trimQuotes(item)
	return createParsedElement(item, ctx)
}

func (v *FSHVisitor) VisitLastContextItem(ctx grammar.ILastContextItemContext) *types.ParsedElement[string] {
	item := ""

	if ctx.LAST_QUOTED_CONTEXT() != nil {
		item = ctx.LAST_QUOTED_CONTEXT().GetText()
	} else if ctx.LAST_UNQUOTED_CONTEXT() != nil {
		item = ctx.LAST_UNQUOTED_CONTEXT().GetText()
	}

	item = strings.Trim(item, ", ")
	item = trimQuotes(item)
	return createParsedElement(item, ctx)
}

func (v *FSHVisitor) VisitCharacteristics(ctx grammar.ICharacteristicsContext) interface{} {
	return v.VisitChildren(ctx)
}

func (v *FSHVisitor) VisitCardRule(ctx grammar.ICardRuleContext) *types.CardRule {
	cardRule := &types.CardRule{}

	if ctx.Path() != nil {
		cardRule.Element = v.VisitPath(ctx.Path())
	}

	card := ctx.CARD().GetText()
	cardRule.Cardinality = createCardinality(card, ctx)

	cardRule.Flags = types.NewFlags()
	for _, flag := range ctx.AllFlag() {
		v.VisitFlag(flag, cardRule.Flags)
	}

	return cardRule
}

func (v *FSHVisitor) VisitFlagRule(ctx grammar.IFlagRuleContext) *types.FlagRule {
	flagRule := &types.FlagRule{}

	for _, element := range ctx.AllPath() {
		flagRule.Elements = append(flagRule.Elements, createParsedElement(element.GetText(), ctx))
	}

	flagRule.Flags = types.NewFlags()
	for _, flag := range ctx.AllFlag() {
		v.VisitFlag(flag, flagRule.Flags)
	}

	return flagRule
}

func (v *FSHVisitor) VisitValueSetRule(ctx grammar.IValueSetRuleContext) *types.BindingRule {
	bindingRule := &types.BindingRule{}

	if ctx.Path() != nil {
		bindingRule.Bindable = v.VisitPath(ctx.Path())
	}
	if ctx.Name() != nil {
		bindingRule.ValueSet = v.VisitName(ctx.Name())
	}
	if ctx.Strength() != nil {
		bindingRule.Strength = v.VisitStrength(ctx.Strength())
	}

	return bindingRule
}

func (v *FSHVisitor) VisitFixedValueRule(ctx grammar.IFixedValueRuleContext) *types.AssignmentRule {
	assignmentRule := &types.AssignmentRule{}

	if ctx.Path() != nil {
		assignmentRule.Element = v.VisitPath(ctx.Path())
	}
	if ctx.Value() != nil {
		assignmentRule.Value = v.VisitValue(ctx.Value())
	}

	if ctx.KW_EXACTLY() != nil {
		assignmentRule.Exactly = createParsedElement(true, ctx)
	} else {
		assignmentRule.Exactly = types.NewParsedElementWithoutLocation(false)
	}

	return assignmentRule
}

func (v *FSHVisitor) VisitContainsRule(ctx grammar.IContainsRuleContext) *types.ContainsRule {
	containsRule := &types.ContainsRule{}

	if ctx.Path() != nil {
		containsRule.Name = v.VisitPath(ctx.Path())
	}

	items := make([]*types.Item, 0)
	for _, item := range ctx.AllItem() {
		items = append(items, v.VisitItem(item))
	}
	containsRule.Items = items

	return containsRule
}

func (v *FSHVisitor) VisitOnlyRule(ctx grammar.IOnlyRuleContext) *types.TypeRule {
	typeRule := &types.TypeRule{}
	if ctx.Path() != nil {
		typeRule.Element = v.VisitPath(ctx.Path())
	}

	typeRule.Types = make([]*types.DataType, 0)
	for _, targetType := range ctx.AllTargetType() {
		typeRule.Types = append(typeRule.Types, v.VisitTargetType(targetType))
	}
	return typeRule
}

func (v *FSHVisitor) VisitObeysRule(ctx grammar.IObeysRuleContext) *types.ObeysRule {
	obeysRule := &types.ObeysRule{}

	// nil path indicates that the obeys rule applies to the whole profile
	if ctx.Path() != nil {
		obeysRule.Element = v.VisitPath(ctx.Path())
	}

	obeysRule.Invariants = make([]*types.ParsedElement[string], 0)

	for _, invariant := range ctx.AllName() {
		obeysRule.Invariants = append(obeysRule.Invariants, v.VisitName(invariant))
	}

	return obeysRule
}

func (v *FSHVisitor) VisitCaretValueRule(ctx grammar.ICaretValueRuleContext) *types.CaretValueRule {
	caretValueRule := &types.CaretValueRule{}

	// nil path indicates that the element is an element of the StructureDefinition
	// non-nil path indicates that the element is an element of an ElementDefinition within a Profile
	if ctx.Path() != nil {
		caretValueRule.ElementInProfile = v.VisitPath(ctx.Path())
	}

	if ctx.CaretPath() != nil {
		caretValueRule.Element = v.VisitCaretPath(ctx.CaretPath())
	}

	if ctx.Value() != nil {
		caretValueRule.Value = v.VisitValue(ctx.Value())
	}

	return caretValueRule
}

func (v *FSHVisitor) VisitCodeCaretValueRule(ctx grammar.ICodeCaretValueRuleContext) *types.CodeCaretValueRule {
	codeCaretValueRule := &types.CodeCaretValueRule{}

	for _, c := range ctx.AllCODE() {
		code := createParsedElement(c.GetText(), ctx)
		codeCaretValueRule.ConceptCodes = append(codeCaretValueRule.ConceptCodes, code)
	}

	if ctx.CaretPath() != nil {
		codeCaretValueRule.Element = v.VisitCaretPath(ctx.CaretPath())
	}
	if ctx.Value() != nil {
		codeCaretValueRule.Value = v.VisitValue(ctx.Value())
	}

	return codeCaretValueRule
}

func (v *FSHVisitor) VisitMappingRule(ctx grammar.IMappingRuleContext) interface{} {
	return v.VisitChildren(ctx)
}

func (v *FSHVisitor) VisitInsertRule(ctx grammar.IInsertRuleContext) *types.InsertRule {
	insertRule := &types.InsertRule{}

	// nil path indicates the rule applies to the context it appears in
	// non-nil path indicates the insert rule is applied within the context of the path
	if ctx.Path() != nil {
		insertRule.Path = v.VisitPath(ctx.Path())
	}

	if ctx.RULESET_REFERENCE() != nil {
		ruleSet := ctx.RULESET_REFERENCE().GetText()
		ruleSet = strings.TrimSpace(ruleSet)
		insertRule.RuleSetName = createParsedElement(ruleSet, ctx)
	}

	insertRule.Parameters = make([]*types.ParsedElement[string], 0)
	if ctx.ParamRuleSetRef() != nil {
		v.VisitParamRuleSetRef(ctx.ParamRuleSetRef(), &insertRule.RuleSetName, &insertRule.Parameters)
	}

	return insertRule
}

func (v *FSHVisitor) VisitCodeInsertRule(ctx grammar.ICodeInsertRuleContext) *types.CodeInsertRule {
	codeInsertRule := &types.CodeInsertRule{}

	for _, c := range ctx.AllCODE() {
		code := createParsedElement(c.GetText(), ctx)
		codeInsertRule.ConceptCodes = append(codeInsertRule.ConceptCodes, code)
	}

	if ctx.RULESET_REFERENCE() != nil {
		ruleSet := ctx.RULESET_REFERENCE().GetText()
		ruleSet = strings.TrimSpace(ruleSet)
		codeInsertRule.RuleSetName = createParsedElement(ruleSet, ctx)
	}

	codeInsertRule.Parameters = make([]*types.ParsedElement[string], 0)
	if ctx.ParamRuleSetRef() != nil {
		v.VisitParamRuleSetRef(ctx.ParamRuleSetRef(), &codeInsertRule.RuleSetName, &codeInsertRule.Parameters)
	}

	return codeInsertRule
}

func (v *FSHVisitor) VisitAddCRElementRule(ctx grammar.IAddCRElementRuleContext) interface{} {
	return v.VisitChildren(ctx)
}

func (v *FSHVisitor) VisitAddElementRule(ctx grammar.IAddElementRuleContext) interface{} {
	return v.VisitChildren(ctx)
}

func (v *FSHVisitor) VisitPathRule(ctx grammar.IPathRuleContext) *types.PathRule {
	pathRule := &types.PathRule{}

	if ctx.Path() != nil {
		pathRule.Path = v.VisitPath(ctx.Path())
	}

	return pathRule
}

// VisitVSComponent appends to either includeComps or excludeComps with the component found in the context.
func (v *FSHVisitor) VisitVSComponent(ctx grammar.IVsComponentContext, includeComps *[]*types.ValueSetComponent, excludeComps *[]*types.ValueSetComponent) {
	component := &types.ValueSetComponent{}

	// this is the code and path when including a single code (not using from syntax)
	if ctx.VsConceptComponent() != nil {
		v.VisitVSConceptComponent(ctx.VsConceptComponent(), component)
	}

	// This is populated when using the from syntax to include codes from a code system or value set
	// even if there are no filters present.
	if ctx.VsFilterComponent() != nil {
		v.VisitVSFilterComponent(ctx.VsFilterComponent(), component)
	}

	if ctx.KW_EXCLUDE() != nil {
		*excludeComps = append(*excludeComps, component)
	} else { // INCLUDE
		// Note, if neither include or exclude keyword is present, we default to include because the include keyword is optional
		// See https://build.fhir.org/ig/HL7/fhir-shorthand/reference.html#defining-value-sets for details.
		*includeComps = append(*includeComps, component)
	}
}

// VisitVSConceptComponent updates component with the source(s) of the codes.
func (v *FSHVisitor) VisitVSConceptComponent(ctx grammar.IVsConceptComponentContext, component *types.ValueSetComponent) {
	if ctx.Code() != nil {
		v.VisitCode(ctx.Code(), component)
	}

	if ctx.VsComponentFrom() != nil {
		v.VisitVSComponentFrom(ctx.VsComponentFrom(), component)
	}
}

// VisitVSFilterComponent updates component with the source of the codes.
func (v *FSHVisitor) VisitVSFilterComponent(ctx grammar.IVsFilterComponentContext, component *types.ValueSetComponent) {
	if ctx.VsComponentFrom() != nil {
		v.VisitVSComponentFrom(ctx.VsComponentFrom(), component)
	}

	if ctx.VsFilterList() != nil {
		v.VisitVSFilterList(ctx.VsFilterList(), &component.Filters)
	}
}

// VisitVSComponentFrom updates component with the source of the codes.
func (v *FSHVisitor) VisitVSComponentFrom(ctx grammar.IVsComponentFromContext, component *types.ValueSetComponent) {
	if ctx.VsFromSystem() != nil {
		v.VisitVSFromSystem(ctx.VsFromSystem(), component)
	}
	if ctx.VsFromValueset() != nil {
		v.VisitVSFromValueset(ctx.VsFromValueset(), component)
	}
}

// VisitVSFromSystem updates component with the codesystems code source.
func (v *FSHVisitor) VisitVSFromSystem(ctx grammar.IVsFromSystemContext, component *types.ValueSetComponent) {
	if ctx.Name() != nil {
		name := ctx.Name().GetText()
		component.FromCodeSystem = createValueSetCodesSource(name, ctx)
	}
}

func (v *FSHVisitor) VisitVSFromValueset(ctx grammar.IVsFromValuesetContext, component *types.ValueSetComponent) {
	for _, name := range ctx.AllName() {
		codesSource := createValueSetCodesSource(name.GetText(), ctx)
		component.FromValueSet = append(component.FromValueSet, codesSource)
	}
}

// VisitVSFilterList updates filters with the filters found in the context.
func (v *FSHVisitor) VisitVSFilterList(ctx grammar.IVsFilterListContext, filters *[]*types.ValueSetFilter) {
	for _, filter := range ctx.AllVsFilterDefinition() {
		f := v.VisitVSFilterDefinition(filter)
		*filters = append(*filters, f)
	}
}

func (v *FSHVisitor) VisitVSFilterDefinition(ctx grammar.IVsFilterDefinitionContext) *types.ValueSetFilter {
	filter := &types.ValueSetFilter{}

	if ctx.Name() != nil {
		filter.Property = v.VisitName(ctx.Name())
	}

	if ctx.VsFilterOperator() != nil {
		filter.Operator = v.VisitVSFilterOperator(ctx.VsFilterOperator())
	}

	if ctx.VsFilterValue() != nil {
		filter.Value = v.VisitVSFilterValue(ctx.VsFilterValue())
	}

	return filter
}

func (v *FSHVisitor) VisitVSFilterOperator(ctx grammar.IVsFilterOperatorContext) *types.ParsedElement[string] {
	return createParsedElement(ctx.GetText(), ctx)
}

func (v *FSHVisitor) VisitVSFilterValue(ctx grammar.IVsFilterValueContext) *types.ParsedElement[string] {
	return createParsedElement(ctx.GetText(), ctx)
}

func (v *FSHVisitor) VisitName(ctx grammar.INameContext) *types.ParsedElement[string] {
	return createParsedElement(ctx.GetText(), ctx)
}

func (v *FSHVisitor) VisitPath(ctx grammar.IPathContext) *types.ParsedElement[string] {
	return createParsedElement(ctx.GetText(), ctx)
}

func (v *FSHVisitor) VisitCaretPath(ctx grammar.ICaretPathContext) *types.ParsedElement[string] {
	deCareted := strings.TrimPrefix(ctx.GetText(), "^")
	return createParsedElement(deCareted, ctx)
}

// VisitFlag updates flags with the flags found in the context.
func (v *FSHVisitor) VisitFlag(ctx grammar.IFlagContext, flags *types.Flags) {
	if ctx.KW_MOD() != nil {
		flags.Modifier = createParsedElement(true, ctx)
	} else if ctx.KW_MS() != nil {
		flags.MustSupport = createParsedElement(true, ctx)
	} else if ctx.KW_SU() != nil {
		flags.IncludeInSummary = createParsedElement(true, ctx)
	} else if ctx.KW_TU() != nil {
		flags.TrialUse = createParsedElement(true, ctx)
	} else if ctx.KW_NORMATIVE() != nil {
		flags.Normative = createParsedElement(true, ctx)
	} else if ctx.KW_DRAFT() != nil {
		flags.Draft = createParsedElement(true, ctx)
	}
}

func (v *FSHVisitor) VisitStrength(ctx grammar.IStrengthContext) *types.ParsedElement[string] {
	return createParsedElement(ctx.GetText(), ctx)
}

func (v *FSHVisitor) VisitValue(ctx grammar.IValueContext) *types.ParsedElement[string] {
	s := ctx.GetText()
	s = trimQuotes(s)
	return createParsedElement(s, ctx)
}

func (v *FSHVisitor) VisitItem(ctx grammar.IItemContext) *types.Item {
	item := &types.Item{}

	names := ctx.AllName()
	if len(names) >= 1 {
		item.Name = v.VisitName(names[0])
	}
	if len(names) >= 2 {
		item.LocalName = v.VisitName(names[1])
	}

	item.Cardinality = createCardinality(ctx.CARD().GetText(), ctx)

	item.Flags = types.NewFlags()
	for _, flag := range ctx.AllFlag() {
		v.VisitFlag(flag, item.Flags)
	}

	return item
}

// VisitCode updates component's CodePath and CodeString field with the values in ctx.
func (v *FSHVisitor) VisitCode(ctx grammar.ICodeContext, component *types.ValueSetComponent) {
	if ctx.CODE() != nil {
		component.CodePath = createParsedElement(ctx.CODE().GetText(), ctx)
	}
	if ctx.STRING() != nil {
		s := ctx.STRING().GetText()
		s = trimQuotes(s)
		component.CodeString = createParsedElement(s, ctx)
	}
}

func (v *FSHVisitor) VisitConcept(ctx grammar.IConceptContext) (*types.Concept, []string) {
	concept := &types.Concept{
		SubConcepts: make([]*types.Concept, 0),
	}
	ancestorPath := make([]string, 0)

	// the last code is the name of the concept
	// anything before that is the "path" of its ancestors
	codes := ctx.AllCODE()
	if len(codes) >= 1 {
		name := trimQuotes(codes[len(codes)-1].GetText())
		concept.Name = createParsedElement(name, ctx)
	}

	// if this concept has ancestors
	if len(codes) > 1 {
		for _, code := range codes[:len(codes)-1] {
			ancestor := trimQuotes(code.GetText())
			ancestorPath = append(ancestorPath, ancestor)
		}
	}

	strings := ctx.AllSTRING()
	if len(strings) >= 1 {
		display := trimQuotes(strings[0].GetText())
		concept.Display = createParsedElement(display, ctx)
	}
	if len(strings) >= 2 {
		definition := trimQuotes(strings[1].GetText())
		concept.Definition = createParsedElement(definition, ctx)
	}

	return concept, ancestorPath
}

func (v *FSHVisitor) VisitQuantity(ctx grammar.IQuantityContext) interface{} {
	return v.VisitChildren(ctx)
}

func (v *FSHVisitor) VisitRatio(ctx grammar.IRatioContext) interface{} {
	return v.VisitChildren(ctx)
}

func (v *FSHVisitor) VisitReference(ctx grammar.IReferenceContext) interface{} {
	return v.VisitChildren(ctx)
}

func (v *FSHVisitor) VisitReferenceType(ctx grammar.IReferenceTypeContext) *types.ParsedElement[string] {
	return createParsedElement(ctx.GetText(), ctx)
}

func (v *FSHVisitor) VisitCodeableReferenceType(ctx grammar.ICodeableReferenceTypeContext) *types.ParsedElement[string] {
	return createParsedElement(ctx.GetText(), ctx)
}

func (v *FSHVisitor) VisitCanonical(ctx grammar.ICanonicalContext) *types.ParsedElement[string] {
	return createParsedElement(ctx.GetText(), ctx)
}

func (v *FSHVisitor) VisitRatioPart(ctx grammar.IRatioPartContext) interface{} {
	return v.VisitChildren(ctx)
}

func (v *FSHVisitor) VisitBool(ctx grammar.IBoolContext) interface{} {
	return v.VisitChildren(ctx)
}

func (v *FSHVisitor) VisitTargetType(ctx grammar.ITargetTypeContext) *types.DataType {
	dataType := &types.DataType{}

	if ctx.Name() != nil {
		dataType.Name = v.VisitName(ctx.Name())
	}
	if ctx.ReferenceType() != nil {
		dataType.ReferenceType = v.VisitReferenceType(ctx.ReferenceType())
	}
	if ctx.Canonical() != nil {
		dataType.Canonical = v.VisitCanonical(ctx.Canonical())
	}
	if ctx.CodeableReferenceType() != nil {
		dataType.CodeableReferenceType = v.VisitCodeableReferenceType(ctx.CodeableReferenceType())
	}

	return dataType
}

func (v *FSHVisitor) VisitMostAlphaKeywords(ctx grammar.IMostAlphaKeywordsContext) interface{} {
	return v.VisitChildren(ctx)
}

// trimQuotes removes quotes around both multiline and singleline strings. trimQuotes
// is needed since strconv.Unquote() does not support multiline strings.
func trimQuotes(s string) string {
	s = strings.Trim(s, "\"")
	s = strings.TrimRight(s, "\"")
	return s
}

// createParsedElement returns a ParsedElement with the given value and tags it
// with the location found from ctx.GetStart() and ctx.GetEnd().
func createParsedElement[T any](value T, ctx antlr.ParserRuleContext) *types.ParsedElement[T] {
	loc := &types.Location{
		Start: &types.Position{
			LineNumber:   ctx.GetStart().GetLine(),
			ColumnNumber: ctx.GetStart().GetColumn(),
		},
		End: &types.Position{
			LineNumber:   ctx.GetStop().GetLine(),
			ColumnNumber: ctx.GetStop().GetColumn(),
		},
	}

	return &types.ParsedElement[T]{
		Value:    value,
		Location: loc,
	}

}

// createCardinality returns a Cardinality from the given cardinality string. Card should be
// in the format "min..max".
func createCardinality(card string, ctx antlr.ParserRuleContext) *types.Cardinality {
	cardinality := &types.Cardinality{}

	parts := strings.Split(card, "..")

	if len(parts) == 2 {
		if parts[0] != "" {
			min, err := strconv.Atoi(parts[0])
			if err == nil {
				cardinality.Min = createParsedElement(min, ctx)
			}
		}

		if parts[1] != "" {
			max, err := strconv.Atoi(parts[1])
			if err == nil {
				cardinality.Max = createParsedElement(max, ctx)
			}
		}
	}

	return cardinality
}

// createValueSetCodesSource returns a ValueSetCodesSource and populates it with the name and version if found.
func createValueSetCodesSource(sourceName string, ctx antlr.ParserRuleContext) *types.ValueSetCodesSource {
	codesSource := &types.ValueSetCodesSource{}

	parts := strings.Split(sourceName, "|")

	if len(parts) >= 1 && parts[0] != "" {
		codesSource.Name = createParsedElement(parts[0], ctx)
	}

	if len(parts) >= 2 && parts[1] != "" {
		codesSource.Version = createParsedElement(parts[1], ctx)
	}
	return codesSource
}
